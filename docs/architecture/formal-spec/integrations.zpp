--------------------------------------------------------------------------------
-- OpenCog Collection - External Integrations Formal Specification (Z++)
--
-- This specification formalizes the contracts and protocols for external
-- system integrations, including storage backends, network protocols,
-- and external service APIs.
--
-- Author: Formal Methods Agent
-- Date: 2025-11-06
--------------------------------------------------------------------------------

-- Import prerequisite specifications
include data_model.zpp
include system_state.zpp
include operations.zpp

--------------------------------------------------------------------------------
-- SECTION 1: Storage Backend Integration Contracts
--------------------------------------------------------------------------------

-- Storage Backend Interface Contract
-- All storage implementations must satisfy this interface
schema StorageBackendContract
  backend: StorageNode
  
  -- Core operations that must be implemented
  store: Atom ‚Üí Result
  fetch: UUID ‚Üí (Atom ‚à™ {null})
  remove: UUID ‚Üí Result
  barrier: () ‚Üí Result  -- Ensure all pending writes complete
  
  -- Batch operations for efficiency
  storeBatch: seq Atom ‚Üí Result
  fetchBatch: seq UUID ‚Üí seq (Atom ‚à™ {null})
  
  -- Query operations
  fetchIncoming: UUID ‚Üí ‚Ñô UUID
  fetchType: AtomType ‚Üí ‚Ñô UUID
where
  -- Invariant: Backend must be connected for operations
  ‚àÄ atom: Atom | store(atom).success = true ‚áí backend.connected = true
  ‚àÄ uuid: UUID | fetch(uuid) ‚â† null ‚áí backend.connected = true
  
  -- Invariant: Store operation updates statistics
  ‚àÄ atom: Atom | store(atom).success = true ‚áí
    backend'.statistics.atomsStored = backend.statistics.atomsStored + 1
  
  -- Invariant: Fetch operation updates statistics
  ‚àÄ uuid: UUID | fetch(uuid) ‚â† null ‚áí
    backend'.statistics.atomsFetched = backend.statistics.atomsFetched + 1
  
  -- Invariant: Batch operations are atomic
  ‚àÄ atoms: seq Atom | 
    storeBatch(atoms).success = true ‚áí
    (‚àÄ atom: Atom | atom ‚àà atoms ‚áí fetch(atom.uuid) = atom)
end

Result ::= {success: ùîπ, errorMessage: String}

-- RocksDB Backend Specification
schema RocksDBBackend extends StorageBackendContract
  dbPath: String
  columnFamilies: ‚Ñô String
  writeOptions: WriteOptions
  readOptions: ReadOptions
  bloomFilterEnabled: ùîπ
where
  -- Backend type must be ROCKSDB
  backend.backendType = ROCKSDB
  
  -- Database path must exist and be writable
  backend.connected = true ‚áí dbPath ‚â† "" ‚àß isWritable(dbPath)
  
  -- Column families for organizing data
  "atoms" ‚àà columnFamilies ‚àß
  "incoming" ‚àà columnFamilies ‚àß
  "types" ‚àà columnFamilies
  
  -- Bloom filter optimization
  bloomFilterEnabled = true ‚áí
    averageReadLatency < averageReadLatencyWithoutFilter / 2
end

WriteOptions ::= {sync: ùîπ, disableWAL: ùîπ}
ReadOptions ::= {verifyChecksums: ùîπ, fillCache: ùîπ}

isWritable: String ‚Üí ùîπ

averageReadLatency: ‚Ñù
averageReadLatencyWithoutFilter: ‚Ñù

-- PostgreSQL Backend Specification
schema PostgreSQLBackend extends StorageBackendContract
  connectionString: String
  schema: String
  tables: ‚Ñô String
  preparedStatements: ‚Ñô PreparedStatement
  connectionPool: ConnectionPool
where
  -- Backend type must be POSTGRESQL
  backend.backendType = POSTGRESQL
  
  -- Connection string must be valid
  backend.connected = true ‚áí 
    connectionString ‚â† "" ‚àß isValidConnectionString(connectionString)
  
  -- Required tables must exist
  "atoms" ‚àà tables ‚àß
  "links" ‚àà tables ‚àß
  "values" ‚àà tables ‚àß
  "incoming_set" ‚àà tables
  
  -- Connection pool for concurrent access
  connectionPool.maxConnections ‚â• 10 ‚àß
  connectionPool.activeConnections ‚â§ connectionPool.maxConnections
  
  -- Prepared statements for performance
  #preparedStatements ‚â• 5  -- insert, update, delete, select, etc.
end

PreparedStatement ::= {name: String, sql: String}

schema ConnectionPool
  maxConnections: ‚Ñï
  activeConnections: ‚Ñï
  idleConnections: ‚Ñï
where
  activeConnections + idleConnections ‚â§ maxConnections
end

isValidConnectionString: String ‚Üí ùîπ

-- Distributed Cog Storage Backend Specification
schema CogStorageBackend extends StorageBackendContract
  remoteAtomSpaceURL: String
  networkProtocol: Protocol
  compressionEnabled: ùîπ
  encryptionEnabled: ùîπ
  retryPolicy: RetryPolicy
where
  -- Backend type must be COG_DISTRIBUTED
  backend.backendType = COG_DISTRIBUTED
  
  -- Remote URL must be valid
  backend.connected = true ‚áí
    remoteAtomSpaceURL ‚â† "" ‚àß isValidURL(remoteAtomSpaceURL)
  
  -- Network protocol typically TCP or WebSocket
  networkProtocol ‚àà {TCP_BINARY, WEBSOCKET}
  
  -- Compression improves network performance
  compressionEnabled = true ‚áí
    backend.statistics.averageWriteLatency < 
    estimateUncompressedLatency / 1.5
  
  -- Retry policy for network failures
  retryPolicy.maxRetries ‚â• 3
  retryPolicy.backoffMultiplier > 1.0
end

schema RetryPolicy
  maxRetries: ‚Ñï
  initialDelay: ‚Ñù  -- milliseconds
  backoffMultiplier: ‚Ñù
  maxDelay: ‚Ñù  -- milliseconds
where
  maxRetries > 0
  initialDelay > 0
  backoffMultiplier ‚â• 1.0
  maxDelay ‚â• initialDelay
end

isValidURL: String ‚Üí ùîπ
estimateUncompressedLatency: ‚Ñù

--------------------------------------------------------------------------------
-- SECTION 2: Network Protocol Specifications
--------------------------------------------------------------------------------

-- TCP Binary Protocol Specification
schema TCPBinaryProtocol
  port: PortNumber
  maxMessageSize: ‚Ñï  -- bytes
  messageFormat: MessageFormat
  keepAliveInterval: ‚Ñï  -- seconds
where
  -- Standard port for CogServer
  port = 17001
  
  -- Message size limit to prevent DoS
  maxMessageSize ‚â§ 100 * 1024 * 1024  -- 100MB limit
  
  -- Message format is S-expressions
  messageFormat = SEXPRESSION
  
  -- Keep-alive to detect dead connections
  keepAliveInterval ‚â• 30 ‚àß keepAliveInterval ‚â§ 300
end

MessageFormat ::= {SEXPRESSION, JSON, BINARY}

-- S-Expression Message Structure
schema SExpressionMessage
  messageType: SExprMessageType
  content: String
  length: ‚Ñï
where
  -- Length must match content
  length = #content
  
  -- Content must be valid S-expression
  isValidSExpression(content)
  
  -- Message type determines parsing
  messageType ‚àà {COMMAND, QUERY, RESPONSE, ERROR}
end

SExprMessageType ::= {COMMAND, QUERY, RESPONSE, ERROR}

isValidSExpression: String ‚Üí ùîπ

-- WebSocket Protocol Specification
schema WebSocketProtocol
  port: PortNumber
  path: String
  subprotocols: ‚Ñô String
  maxFrameSize: ‚Ñï
  pingInterval: ‚Ñï  -- seconds
where
  -- Standard WebSocket port
  port = 18080
  
  -- Different paths for different APIs
  path ‚àà {"/py", "/scm", "/json"}
  
  -- Supported subprotocols
  "opencog-sexpr" ‚àà subprotocols ‚à®
  "opencog-json" ‚àà subprotocols
  
  -- Frame size limit
  maxFrameSize ‚â§ 10 * 1024 * 1024  -- 10MB
  
  -- Ping/pong for connection health
  pingInterval ‚â• 10 ‚àß pingInterval ‚â§ 60
end

-- JSON API Protocol Specification
schema JSONAPIProtocol
  version: String
  endpoints: ‚Ñô APIEndpoint
  requestFormat: JSONRequestFormat
  responseFormat: JSONResponseFormat
where
  -- API version
  version = "1.0"
  
  -- Standard endpoints
  ‚àÉ ep: APIEndpoint | 
    ep ‚àà endpoints ‚àß ep.path = "/atomspace/query" ‚àß
  ‚àÉ ep: APIEndpoint |
    ep ‚àà endpoints ‚àß ep.path = "/atomspace/create" ‚àß
  ‚àÉ ep: APIEndpoint |
    ep ‚àà endpoints ‚àß ep.path = "/atomspace/update"
  
  -- Request format
  requestFormat.encoding = UTF8
  requestFormat.contentType = "application/json"
  
  -- Response format
  responseFormat.encoding = UTF8
  responseFormat.includeMetadata = true
end

schema APIEndpoint
  path: String
  method: HTTPMethod
  parameters: ‚Ñô Parameter
  authentication: ùîπ
where
  path ‚â† ""
  method ‚àà {GET, POST, PUT, DELETE}
end

HTTPMethod ::= {GET, POST, PUT, DELETE, PATCH}

schema Parameter
  name: String
  type: ParameterType
  required: ùîπ
end

ParameterType ::= {STRING, INTEGER, BOOLEAN, OBJECT, ARRAY}

schema JSONRequestFormat
  encoding: Encoding
  contentType: String
  maxSize: ‚Ñï
end

schema JSONResponseFormat
  encoding: Encoding
  contentType: String
  includeMetadata: ùîπ
end

Encoding ::= {UTF8, UTF16, ASCII}

-- Model Context Protocol (MCP) Specification
schema MCPProtocol
  version: String
  transport: MCPTransport
  capabilities: ‚Ñô MCPCapability
  tools: ‚Ñô MCPTool
where
  -- MCP version
  version = "1.0"
  
  -- Transport can be stdio or HTTP
  transport ‚àà {STDIO, HTTP}
  
  -- Capabilities supported
  "tools/list" ‚àà capabilities ‚àß
  "tools/call" ‚àà capabilities ‚àß
  "resources/read" ‚àà capabilities
  
  -- AtomSpace tools exposed via MCP
  ‚àÉ tool: MCPTool |
    tool ‚àà tools ‚àß tool.name = "query_atomspace" ‚àß
  ‚àÉ tool: MCPTool |
    tool ‚àà tools ‚àß tool.name = "create_atom"
end

MCPTransport ::= {STDIO, HTTP}
MCPCapability ::= String

schema MCPTool
  name: String
  description: String
  inputSchema: JSONSchema
  handler: ToolHandler
end

JSONSchema ::= String  -- Simplified representation
ToolHandler ::= Function  -- Abstract function type

--------------------------------------------------------------------------------
-- SECTION 3: External Service API Contracts
--------------------------------------------------------------------------------

-- LLM Inference Service Contract (Aphrodite Engine)
schema LLMInferenceContract
  serviceURL: String
  apiKey: String
  model: String
  maxTokens: ‚Ñï
  temperature: {r: ‚Ñù | 0 ‚â§ r ‚â§ 2}
  
  -- Operations
  generateText: TextPrompt ‚Üí GeneratedText
  generateEmbedding: String ‚Üí Vector
  streamGeneration: TextPrompt ‚Üí Stream‚ü®TokenChunk‚ü©
where
  -- Service must be accessible
  isValidURL(serviceURL)
  
  -- API key required for authentication
  apiKey ‚â† "" ‚áí isSecureConnection(serviceURL)
  
  -- Model must be loaded
  model ‚â† ""
  
  -- Token limit must be reasonable
  0 < maxTokens ‚â§ 100000
  
  -- Temperature controls randomness
  0 ‚â§ temperature ‚â§ 2
  
  -- Generation respects token limit
  ‚àÄ prompt: TextPrompt; result: GeneratedText |
    result = generateText(prompt) ‚áí
    #result.tokens ‚â§ maxTokens
end

schema TextPrompt
  text: String
  systemPrompt: String
  stopSequences: seq String
where
  text ‚â† ""
end

schema GeneratedText
  text: String
  tokens: seq String
  logprobs: seq ‚Ñù
  finishReason: FinishReason
where
  #tokens = #logprobs
end

FinishReason ::= {COMPLETED, LENGTH_LIMIT, STOP_SEQUENCE, ERROR}

Vector ::= seq ‚Ñù

Stream‚ü®T‚ü© ::= seq T

schema TokenChunk
  token: String
  logprob: ‚Ñù
  index: ‚Ñï
end

isSecureConnection: String ‚Üí ùîπ

-- Knowledge Graph Integration Contract (GnuCash)
schema KnowledgeGraphContract
  dataSource: String
  schemaMapping: EntityType ‚á∏ AtomType
  syncInterval: ‚Ñï  -- seconds
  bidirectional: ùîπ
  
  -- Operations
  importEntities: ‚Ñô Entity ‚Üí ‚Ñô UUID
  exportAtoms: ‚Ñô UUID ‚Üí ‚Ñô Entity
  synchronize: () ‚Üí SyncResult
where
  -- Data source must be accessible
  dataSource ‚â† ""
  
  -- Schema mapping must be complete
  ‚àÄ et: EntityType | et ‚àà supportedEntityTypes ‚áí
    et ‚àà dom schemaMapping
  
  -- Sync interval reasonable for performance
  syncInterval ‚â• 60  -- At least 1 minute
  
  -- Bidirectional sync requires write access
  bidirectional = true ‚áí hasWriteAccess(dataSource)
  
  -- Import creates valid atoms
  ‚àÄ entities: ‚Ñô Entity; uuids: ‚Ñô UUID |
    uuids = importEntities(entities) ‚áí
    ‚àÄ uuid: UUID | uuid ‚àà uuids ‚áí
      uuid ‚àà dom atomSpaceUUIDs
end

EntityType ::= String
supportedEntityTypes: ‚Ñô EntityType

schema Entity
  entityID: String
  entityType: EntityType
  properties: String ‚á∏ String
end

schema SyncResult
  entitiesImported: ‚Ñï
  atomsExported: ‚Ñï
  conflicts: ‚Ñô Conflict
  success: ùîπ
end

schema Conflict
  entityID: String
  atomUUID: UUID
  reason: String
end

hasWriteAccess: String ‚Üí ùîπ
atomSpaceUUIDs: ‚Ñô UUID

-- Story/World Modeling Service Contract (KoboldCpp)
schema WorldModelingContract
  serviceURL: String
  model: String
  contextSize: ‚Ñï
  
  -- Operations
  generateStory: StoryPrompt ‚Üí StoryOutput
  updateWorldState: WorldState ‚Üí Result
  queryWorld: WorldQuery ‚Üí WorldAnswer
where
  -- Service must be accessible
  isValidURL(serviceURL)
  
  -- Model must support world modeling
  model ‚â† ""
  
  -- Context size determines memory
  contextSize ‚â• 2048
  
  -- Story generation preserves world consistency
  ‚àÄ prompt: StoryPrompt; output: StoryOutput |
    output = generateStory(prompt) ‚áí
    isConsistentWithWorld(output, prompt.worldState)
end

schema StoryPrompt
  prompt: String
  worldState: WorldState
  characters: ‚Ñô Character
  constraints: ‚Ñô String
end

schema WorldState
  facts: ‚Ñô String
  entities: ‚Ñô Entity
  relationships: ‚Ñô Relationship
end

schema Character
  name: String
  traits: ‚Ñô String
  relationships: ‚Ñô Relationship
end

schema Relationship
  subject: String
  predicate: String
  object: String
end

schema StoryOutput
  generatedText: String
  updatedWorldState: WorldState
  characterActions: ‚Ñô Action
end

schema Action
  character: String
  actionType: String
  target: String
end

schema WorldQuery
  queryText: String
  context: WorldState
end

schema WorldAnswer
  answerText: String
  confidence: {r: ‚Ñù | 0 ‚â§ r ‚â§ 1}
  sources: ‚Ñô String
end

isConsistentWithWorld: StoryOutput √ó WorldState ‚Üí ùîπ

--------------------------------------------------------------------------------
-- SECTION 4: Inter-Component Communication Protocols
--------------------------------------------------------------------------------

-- AtomSpace-CogServer Communication
operation AtomSpaceServerCommunication
  ŒûAtomSpace
  ŒîCogServer
  command?: String
  response!: String
where
  -- CogServer parses command
  let parsedCommand = parseCommand(command?)
  
  -- Execute on AtomSpace based on command type
  (parsedCommand.type = QUERY ‚áí
    ‚àÉ pattern: QueryPattern; results: seq UUID |
      ExecuteQuery(pattern, results, _) ‚àß
      response! = formatResults(results))
  
  ‚à®
  
  (parsedCommand.type = CREATE ‚áí
    ‚àÉ atomType: AtomType; newUUID: UUID |
      CreateAtom(atomType, _, _, _, _, newUUID) ‚àß
      response! = formatUUID(newUUID))
  
  ‚à®
  
  (parsedCommand.type = UPDATE ‚áí
    ‚àÉ uuid: UUID; success: ùîπ |
      UpdateAtom(uuid, _, _, success) ‚àß
      response! = formatSuccess(success))
end

parseCommand: String ‚Üí ParsedCommand

schema ParsedCommand
  type: CommandType
  parameters: String ‚á∏ String
end

CommandType ::= {QUERY, CREATE, UPDATE, DELETE, INFERENCE}

formatResults: seq UUID ‚Üí String
formatUUID: UUID ‚Üí String
formatSuccess: ùîπ ‚Üí String

-- CogGML-AtomSpace Communication
operation ShardAtomSpaceCommunication
  ŒîCognitiveShard
  ŒûAtomSpace
  task?: CognitiveTask
  results!: seq UUID
where
  -- Shard executes task using AtomSpace
  task?.taskType = REASONING ‚áí
    ‚àÉ pattern: QueryPattern; queryResults: seq UUID |
      ExecuteQuery(pattern, queryResults, _) ‚àß
      results! = queryResults
  
  ‚à®
  
  task?.taskType = PATTERN_MATCHING ‚áí
    ‚àÉ pattern: QueryPattern; matches: seq UUID |
      ExecuteQuery(pattern, matches, _) ‚àß
      results! = matches
  
  -- Shard updates self-awareness metrics
  ŒîCognitiveShard.selfAwarenessMetrics.taskCompletionRate' =
    calculateNewCompletionRate(task?, results!)
end

calculateNewCompletionRate: CognitiveTask √ó seq UUID ‚Üí ‚Ñù

-- CogSelf-Subsystem Coordination
operation CogSelfSubsystemCoordination
  ŒîCogSelf
  ŒîCogGMLSubsystem
  ŒîReasoningSubsystem
  ŒîLearningSubsystem
where
  -- CogSelf coordinates all subsystems
  
  -- Activate required shards
  ‚àÄ component: ComponentID |
    component ‚àà CogSelf.synergyManager.components ‚áí
    component = COGGML ‚áí
      #CogGMLSubsystem'.coordinator.activeShards ‚â• 1
  
  -- Trigger reasoning if needed
  CogSelf.goals contains reasoning goal ‚áí
    ReasoningSubsystem'.plnEngine.currentInferences ‚â† ‚àÖ
  
  -- Trigger learning if needed
  CogSelf.goals contains learning goal ‚áí
    LearningSubsystem'.mosesEngine.currentGeneration' >
    LearningSubsystem.mosesEngine.currentGeneration
  
  -- Update synergy based on subsystem interactions
  let interactions = 
    measureSubsystemInteractions(
      CogGMLSubsystem,
      ReasoningSubsystem,
      LearningSubsystem
    )
  
  CogSelf'.synergyManager.overallSynergyLevel = 
    calculateSynergyLevel(interactions)
end

measureSubsystemInteractions: 
  CogGMLSubsystem √ó ReasoningSubsystem √ó LearningSubsystem ‚Üí ‚Ñù

calculateSynergyLevel: ‚Ñù ‚Üí {r: ‚Ñù | 0 ‚â§ r ‚â§ 1}

--------------------------------------------------------------------------------
-- SECTION 5: Error Handling and Recovery Protocols
--------------------------------------------------------------------------------

-- Storage Backend Error Recovery
operation StorageErrorRecovery
  ŒîStorageBackendContract
  error?: StorageError
  recovered!: ùîπ
where
  -- Error types
  error?.errorType = CONNECTION_LOST ‚áí
    -- Attempt reconnection with backoff
    let reconnected = attemptReconnect(
      backend,
      maxRetries ‚áí 3,
      initialDelay ‚áí 1000
    )
    recovered! = reconnected ‚àß
    backend'.connected = reconnected
  
  ‚à®
  
  error?.errorType = WRITE_FAILURE ‚áí
    -- Retry write operation
    let writeSucceeded = retryWrite(error?.failedOperation, maxRetries ‚áí 3)
    recovered! = writeSucceeded
  
  ‚à®
  
  error?.errorType = CORRUPTION_DETECTED ‚áí
    -- Attempt data recovery
    recovered! = false  -- Requires manual intervention
    -- Log critical error
end

schema StorageError
  errorType: StorageErrorType
  errorMessage: String
  failedOperation: Operation
  timestamp: Timestamp
end

StorageErrorType ::= {CONNECTION_LOST, WRITE_FAILURE, READ_FAILURE,
                      CORRUPTION_DETECTED, TIMEOUT}

Operation ::= String  -- Simplified representation

attemptReconnect: StorageNode √ó ‚Ñï √ó ‚Ñù ‚Üí ùîπ
retryWrite: Operation √ó ‚Ñï ‚Üí ùîπ

-- Network Protocol Error Recovery
operation NetworkErrorRecovery
  ŒîConnection
  error?: NetworkError
  recovered!: ùîπ
where
  error?.errorType = TIMEOUT ‚áí
    -- Increase timeout and retry
    let newTimeout = error?.currentTimeout * 1.5
    recovered! = retryWithTimeout(error?.operation, newTimeout)
  
  ‚à®
  
  error?.errorType = PROTOCOL_ERROR ‚áí
    -- Reset connection
    Connection'.state = CONNECTING ‚àß
    recovered! = false
  
  ‚à®
  
  error?.errorType = AUTHENTICATION_FAILURE ‚áí
    -- Require re-authentication
    Connection'.state = AUTHENTICATING ‚àß
    recovered! = false
end

schema NetworkError
  errorType: NetworkErrorType
  errorMessage: String
  operation: String
  currentTimeout: ‚Ñù
end

NetworkErrorType ::= {TIMEOUT, PROTOCOL_ERROR, AUTHENTICATION_FAILURE,
                      CONNECTION_REFUSED, BUFFER_OVERFLOW}

retryWithTimeout: String √ó ‚Ñù ‚Üí ùîπ

-- External Service Error Recovery
operation ExternalServiceRecovery
  error?: ServiceError
  fallbackStrategy?: FallbackStrategy
  recovered!: ùîπ
where
  error?.serviceType = LLM_INFERENCE ‚áí
    fallbackStrategy? = USE_CACHED_RESPONSES ‚áí
      recovered! = true
    ‚à®
    fallbackStrategy? = USE_ALTERNATIVE_SERVICE ‚áí
      let alternativeAvailable = checkAlternativeService()
      recovered! = alternativeAvailable
  
  ‚à®
  
  error?.serviceType = WORLD_MODELING ‚áí
    fallbackStrategy? = DEGRADE_GRACEFULLY ‚áí
      recovered! = true  -- Continue without world modeling
end

schema ServiceError
  serviceType: ServiceType
  errorMessage: String
  retryable: ùîπ
end

ServiceType ::= {LLM_INFERENCE, WORLD_MODELING, KNOWLEDGE_GRAPH}

FallbackStrategy ::= {USE_CACHED_RESPONSES, USE_ALTERNATIVE_SERVICE,
                      DEGRADE_GRACEFULLY, FAIL_FAST}

checkAlternativeService: () ‚Üí ùîπ

--------------------------------------------------------------------------------
-- SECTION 6: Performance and Quality of Service Contracts
--------------------------------------------------------------------------------

-- Storage Performance SLA
schema StoragePerformanceSLA
  backend: StorageBackendContract
  maxReadLatency: ‚Ñù  -- milliseconds
  maxWriteLatency: ‚Ñù  -- milliseconds
  minThroughput: ‚Ñï  -- operations per second
  maxErrorRate: {r: ‚Ñù | 0 ‚â§ r ‚â§ 1}
where
  -- Performance guarantees
  backend.statistics.averageReadLatency ‚â§ maxReadLatency
  backend.statistics.averageWriteLatency ‚â§ maxWriteLatency
  
  -- Throughput requirement
  let throughput = 
    (backend.statistics.totalReads + backend.statistics.totalWrites) /
    measurementWindow
  throughput ‚â• minThroughput
  
  -- Error rate must be low
  let errorRate = 
    (backend.statistics.totalReads + backend.statistics.totalWrites - 
     backend.statistics.atomsStored - backend.statistics.atomsFetched) /
    max(backend.statistics.totalReads + backend.statistics.totalWrites, 1)
  errorRate ‚â§ maxErrorRate
end

measurementWindow: ‚Ñù  -- seconds

-- Network Performance SLA
schema NetworkPerformanceSLA
  server: CogServer
  maxResponseTime: ‚Ñù  -- milliseconds
  minAvailability: {r: ‚Ñù | 0 ‚â§ r ‚â§ 1}
  maxConcurrentConnections: ‚Ñï
where
  -- Response time guarantee
  server.networkStatistics.averageResponseTime ‚â§ maxResponseTime
  
  -- Availability requirement
  let availability = 
    server.uptime / (server.uptime + server.downtime)
  availability ‚â• minAvailability
  
  -- Connection capacity
  server.networkStatistics.activeConnections ‚â§ maxConcurrentConnections
end

-- External Service SLA
schema ExternalServiceSLA
  service: LLMInferenceContract
  maxLatency: ‚Ñù  -- milliseconds
  minSuccessRate: {r: ‚Ñù | 0 ‚â§ r ‚â§ 1}
  maxCostPerRequest: ‚Ñù  -- dollars
where
  -- Latency guarantee
  averageServiceLatency ‚â§ maxLatency
  
  -- Success rate requirement
  let successRate = successfulRequests / totalRequests
  successRate ‚â• minSuccessRate
  
  -- Cost constraint
  averageCostPerRequest ‚â§ maxCostPerRequest
end

averageServiceLatency: ‚Ñù
successfulRequests: ‚Ñï
totalRequests: ‚Ñï
averageCostPerRequest: ‚Ñù

--------------------------------------------------------------------------------
-- SECTION 7: Integration Invariants
--------------------------------------------------------------------------------

-- Invariant: All storage operations maintain AtomSpace consistency
invariant StorageAtomSpaceConsistency
  ‚àÄ backend: StorageBackendContract;
    atom: Atom |
    backend.store(atom).success = true ‚áí
    backend.fetch(atom.uuid) = atom

-- Invariant: Network communication preserves data integrity
invariant NetworkDataIntegrity
  ‚àÄ conn: Connection;
    request: Request;
    response: Response |
    response.requestID = request.requestID ‚áí
    response.connectionID = request.connectionID

-- Invariant: External services maintain semantic consistency
invariant ExternalServiceConsistency
  ‚àÄ llm: LLMInferenceContract;
    prompt: TextPrompt;
    result: GeneratedText |
    result = llm.generateText(prompt) ‚áí
    isSemanticallyconsistent(prompt.text, result.text)

isSemanticallyconsistent: String √ó String ‚Üí ùîπ

-- Invariant: Integration errors trigger appropriate recovery
invariant ErrorRecoveryGuarantee
  ‚àÄ error: StorageError ‚à™ NetworkError ‚à™ ServiceError |
    error.retryable = true ‚áí
    ‚àÉ recovery: RecoveryOperation |
      recovery.error = error ‚àß
      recovery.recovered = true ‚à®
      recovery.attemptsExhausted = true

RecoveryOperation ::= {error: Error, recovered: ùîπ, attemptsExhausted: ùîπ}
Error ::= StorageError ‚à™ NetworkError ‚à™ ServiceError

--------------------------------------------------------------------------------
-- End of External Integrations Specification
--------------------------------------------------------------------------------
