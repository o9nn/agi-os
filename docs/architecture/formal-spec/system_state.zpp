--------------------------------------------------------------------------------
-- OpenCog Collection - System State Formal Specification (Z++)
--
-- This specification formalizes the overall system state, component integration,
-- and global state invariants of the OpenCog Collection.
--
-- Author: Formal Methods Agent
-- Date: 2025-11-06
--------------------------------------------------------------------------------

-- Import data model definitions
include data_model.zpp

--------------------------------------------------------------------------------
-- SECTION 1: Component State Schemas
--------------------------------------------------------------------------------

-- AtomSpace subsystem state
schema AtomSpaceSubsystem
  instances: UUID ‚á∏ AtomSpace
  defaultInstance: UUID
  storageBackends: UUID ‚á∏ StorageNode
  queryCache: QueryCache
  statistics: AtomSpaceStatistics
where
  -- Default instance must exist
  defaultInstance ‚àà dom instances
  
  -- All instances must have valid UUIDs
  ‚àÄ uuid: UUID | uuid ‚àà dom instances ‚áí uuid ‚â† 0
  
  -- Storage backends are optional but must be valid if present
  ‚àÄ sid: UUID; storage: StorageNode | (sid, storage) ‚àà storageBackends ‚áí
    storage.connected = true
end

-- Query cache for performance optimization
schema QueryCache
  cachedQueries: QueryPattern ‚á∏ QueryResult
  cacheHits: ‚Ñï
  cacheMisses: ‚Ñï
  maxCacheSize: ‚Ñï
where
  -- Cache size must not exceed maximum
  #cachedQueries ‚â§ maxCacheSize
  
  -- Hit rate can be calculated from hits and misses
  cacheHits + cacheMisses > 0 ‚áí 
    cacheHits ‚â§ cacheHits + cacheMisses
end

QueryPattern ::= String  -- Simplified representation
QueryResult ::= seq UUID  -- Result atom UUIDs

-- AtomSpace usage statistics
schema AtomSpaceStatistics
  totalAtoms: ‚Ñï
  totalLinks: ‚Ñï
  totalNodes: ‚Ñï
  queriesExecuted: ‚Ñï
  averageQueryTime: ‚Ñù  -- milliseconds
  memoryUsage: ‚Ñï  -- bytes
where
  -- Links + Nodes = Total Atoms
  totalAtoms = totalLinks + totalNodes
  
  -- Query time must be non-negative
  averageQueryTime ‚â• 0
  
  -- Memory usage must be reasonable
  memoryUsage > 0
end

-- CogServer subsystem state
schema CogServerSubsystem
  server: CogServer
  activeUsers: ‚Ñô String
  requestQueue: seq Request
  responseQueue: seq Response
  networkStatistics: NetworkStatistics
where
  -- Active users must correspond to authenticated connections
  activeUsers = {conn.authenticatedUser | 
                 conn: Connection | 
                 conn ‚àà ran server.connections ‚àß 
                 conn.state = AUTHENTICATED ‚àß
                 conn.authenticatedUser ‚â† ""}
  
  -- Request and response queues must be bounded
  #requestQueue ‚â§ 10000
  #responseQueue ‚â§ 10000
end

-- Network request representation
schema Request
  requestID: UUID
  connectionID: ConnectionID
  command: String
  receivedAt: Timestamp
  status: RequestStatus
where
  receivedAt > 0
  command ‚â† ""
end

RequestStatus ::= {PENDING, PROCESSING, COMPLETED, FAILED}

-- Network response representation
schema Response
  responseID: UUID
  requestID: UUID
  connectionID: ConnectionID
  result: String
  sentAt: Timestamp
where
  sentAt > 0
end

-- Network performance statistics
schema NetworkStatistics
  totalRequests: ‚Ñï
  successfulRequests: ‚Ñï
  failedRequests: ‚Ñï
  averageResponseTime: ‚Ñù  -- milliseconds
  bytesReceived: ‚Ñï
  bytesSent: ‚Ñï
  activeConnections: ‚Ñï
where
  -- Successful + Failed ‚â§ Total
  successfulRequests + failedRequests ‚â§ totalRequests
  
  -- Response time must be non-negative
  averageResponseTime ‚â• 0
  
  -- Network traffic must be non-negative
  bytesReceived ‚â• 0 ‚àß bytesSent ‚â• 0
end

-- CogGML subsystem state
schema CogGMLSubsystem
  microkernel: Microkernel
  coordinator: ShardCoordinator
  shardPool: ‚Ñô UUID  -- Available shards
  executionMetrics: ExecutionMetrics
where
  -- All shards in pool must be registered with coordinator
  shardPool ‚äÜ dom coordinator.shards
  
  -- At least one shard should exist for meaningful operation
  #shardPool > 0
end

-- Microkernel state
schema Microkernel
  initialized: ùîπ
  threadPool: ‚Ñô ThreadID
  taskQueue: seq CognitiveTask
  maxConcurrentTasks: ‚Ñï
where
  -- Thread pool size should not exceed reasonable limits
  #threadPool ‚â§ 1000
  
  -- Task queue should be bounded
  #taskQueue ‚â§ 10000
  
  -- Cannot have more concurrent tasks than threads
  maxConcurrentTasks ‚â§ #threadPool
end

ThreadID ::= ‚Ñï

-- Cognitive task representation
schema CognitiveTask
  taskID: UUID
  assignedShard: UUID
  taskType: TaskType
  status: TaskStatus
  createdAt: Timestamp
  completedAt: Timestamp  -- 0 if not completed
where
  -- Temporal consistency
  completedAt = 0 ‚à® completedAt ‚â• createdAt
  
  -- Completed tasks must have COMPLETED status
  completedAt > 0 ‚áí status = COMPLETED
end

TaskType ::= {REASONING, LEARNING, PATTERN_MATCHING, INFERENCE, OPTIMIZATION}
TaskStatus ::= {QUEUED, ASSIGNED, RUNNING, COMPLETED, FAILED}

-- Execution performance metrics
schema ExecutionMetrics
  tasksCompleted: ‚Ñï
  tasksFailed: ‚Ñï
  averageExecutionTime: ‚Ñù  -- milliseconds
  cpuUtilization: {r: ‚Ñù | 0 ‚â§ r ‚â§ 1}  -- 0 to 1
  memoryUtilization: {r: ‚Ñù | 0 ‚â§ r ‚â§ 1}  -- 0 to 1
where
  -- Utilization must be bounded
  0 ‚â§ cpuUtilization ‚â§ 1
  0 ‚â§ memoryUtilization ‚â§ 1
  
  -- Execution time must be non-negative
  averageExecutionTime ‚â• 0
end

-- CogSelf subsystem state
schema CogSelfSubsystem
  framework: CogSelf
  assessmentHistory: seq AGIAssessment
  autonomousMode: ùîπ
  lastSelfImprovement: Timestamp
where
  -- Assessment history should track progress over time
  #assessmentHistory > 0 ‚áí
    ‚àÄ i: ‚Ñï | i < #assessmentHistory - 1 ‚áí
      assessmentHistory·µ¢.timestamp < assessmentHistory·µ¢‚Çä‚ÇÅ.timestamp
end

-- AGI progress assessment snapshot
schema AGIAssessment
  assessmentID: UUID
  timestamp: Timestamp
  overallProgress: {r: ‚Ñù | 0 ‚â§ r ‚â§ 1}
  synergyLevel: {r: ‚Ñù | 0 ‚â§ r ‚â§ 1}
  goalProgress: UUID ‚á∏ {r: ‚Ñù | 0 ‚â§ r ‚â§ 1}  -- Per-goal progress
  recommendations: seq String
where
  -- Progress and synergy must be bounded
  0 ‚â§ overallProgress ‚â§ 1
  0 ‚â§ synergyLevel ‚â§ 1
  
  -- All goals must have valid progress
  ‚àÄ gid: UUID; progress: ‚Ñù | (gid, progress) ‚àà goalProgress ‚áí
    0 ‚â§ progress ‚â§ 1
end

-- Reasoning subsystem state (PLN + URE)
schema ReasoningSubsystem
  plnEngine: PLNEngine
  ureEngine: UREEngine
  inferenceCache: InferenceCache
  reasoningStatistics: ReasoningStatistics
end

-- PLN (Probabilistic Logic Networks) engine state
schema PLNEngine
  ruleBase: ‚Ñô InferenceRule
  truthValueFunction: TruthValueFunction
  maxInferenceSteps: ‚Ñï
  currentInferences: ‚Ñô UUID  -- Currently active inferences
where
  -- Rule base should not be empty for useful reasoning
  #ruleBase > 0
  
  -- Max inference steps should be reasonable
  maxInferenceSteps > 0 ‚àß maxInferenceSteps ‚â§ 1000
end

-- URE (Unified Rule Engine) state
schema UREEngine
  rules: ‚Ñô Rule
  backwardChainer: BackwardChainer
  forwardChainer: ForwardChainer
  ruleApplicationHistory: seq RuleApplication
where
  -- Rules should exist
  #rules > 0
end

schema InferenceRule
  ruleID: UUID
  premise: seq UUID  -- Atom UUIDs forming premise
  conclusion: UUID  -- Resulting atom
  confidence: {r: ‚Ñù | 0 ‚â§ r ‚â§ 1}
end

TruthValueFunction ::= Function  -- Abstract function type

schema Rule
  ruleID: UUID
  name: String
  pattern: Pattern
  action: Action
end

Pattern ::= String  -- Simplified representation
Action ::= String  -- Simplified representation

schema BackwardChainer
  targetGoals: ‚Ñô UUID
  searchDepth: ‚Ñï
  maxIterations: ‚Ñï
where
  searchDepth ‚â§ 10  -- Prevent excessive depth
  maxIterations ‚â§ 1000
end

schema ForwardChainer
  premises: ‚Ñô UUID
  maxIterations: ‚Ñï
where
  maxIterations ‚â§ 1000
end

schema RuleApplication
  applicationID: UUID
  ruleID: UUID
  timestamp: Timestamp
  success: ùîπ
end

-- Inference result cache
schema InferenceCache
  cachedInferences: (Pattern √ó seq UUID) ‚á∏ seq UUID  -- Input -> Output
  cacheSize: ‚Ñï
  maxCacheSize: ‚Ñï
where
  #cachedInferences ‚â§ maxCacheSize
  cacheSize = #cachedInferences
end

-- Reasoning performance statistics
schema ReasoningStatistics
  inferencesPerformed: ‚Ñï
  successfulInferences: ‚Ñï
  averageInferenceTime: ‚Ñù  -- milliseconds
  cacheHitRate: {r: ‚Ñù | 0 ‚â§ r ‚â§ 1}
where
  -- Successful inferences ‚â§ Total inferences
  successfulInferences ‚â§ inferencesPerformed
  
  -- Inference time must be non-negative
  averageInferenceTime ‚â• 0
end

-- Learning subsystem state (MOSES + Learn modules)
schema LearningSubsystem
  mosesEngine: MOSESEngine
  languageLearner: LanguageLearner
  patternMiner: PatternMiner
  learningStatistics: LearningStatistics
end

-- MOSES (Meta-Optimizing Semantic Evolutionary Search) engine
schema MOSESEngine
  population: ‚Ñô Program
  fitnessFunction: FitnessFunction
  maxGenerations: ‚Ñï
  currentGeneration: ‚Ñï
  bestProgram: Program
where
  -- Population should not be empty
  #population > 0
  
  -- Current generation should not exceed max
  currentGeneration ‚â§ maxGenerations
  
  -- Best program should be in population
  bestProgram ‚àà population
end

Program ::= String  -- Simplified representation
FitnessFunction ::= Function  -- Abstract function type

-- Language learning state
schema LanguageLearner
  corpus: ‚Ñô String  -- Text corpus
  learnedGrammar: Grammar
  vocabularySize: ‚Ñï
where
  vocabularySize > 0
end

Grammar ::= String  -- Simplified representation

-- Pattern mining state
schema PatternMiner
  minedPatterns: ‚Ñô Pattern
  supportThreshold: {r: ‚Ñù | 0 ‚â§ r ‚â§ 1}
  confidenceThreshold: {r: ‚Ñù | 0 ‚â§ r ‚â§ 1}
where
  -- Thresholds must be in valid range
  0 ‚â§ supportThreshold ‚â§ 1
  0 ‚â§ confidenceThreshold ‚â§ 1
end

-- Learning performance statistics
schema LearningStatistics
  patternsDiscovered: ‚Ñï
  programsEvolved: ‚Ñï
  vocabularyGrowth: ‚Ñï
  averageLearningTime: ‚Ñù  -- milliseconds
where
  averageLearningTime ‚â• 0
  patternsDiscovered ‚â• 0
  programsEvolved ‚â• 0
end

-- Attention allocation subsystem
schema AttentionSubsystem
  economicAttentionNetwork: ECAN
  importanceUpdates: seq ImportanceUpdate
  attentionStatistics: AttentionStatistics
end

-- Economic Attention Networks (ECAN)
schema ECAN
  attentionBank: AttentionBank
  stimulusSources: ‚Ñô StimulusSource
  forgettingStrategy: ForgettingStrategy
where
  -- At least one stimulus source should exist
  #stimulusSources > 0
end

schema AttentionBank
  totalSTI: STI  -- Total short-term importance in system
  totalLTI: LTI  -- Total long-term importance in system
  stiWage: STI  -- STI distributed per cycle
  ltiWage: LTI  -- LTI distributed per cycle
where
  -- Wages should be positive for meaningful attention dynamics
  stiWage > 0
  ltiWage > 0
end

StimulusSource ::= String  -- Simplified representation
ForgettingStrategy ::= {PROBABILISTIC, THRESHOLD, HYBRID}

schema ImportanceUpdate
  updateID: UUID
  atomID: UUID
  oldSTI: STI
  newSTI: STI
  timestamp: Timestamp
where
  timestamp > 0
end

schema AttentionStatistics
  totalUpdates: ‚Ñï
  averageSTI: ‚Ñù
  averageLTI: ‚Ñù
  atomsForgotten: ‚Ñï
where
  totalUpdates ‚â• 0
  atomsForgotten ‚â• 0
end

--------------------------------------------------------------------------------
-- SECTION 2: Integrated System State
--------------------------------------------------------------------------------

-- Top-level system state integrating all subsystems
schema OpenCogSystemState
  atomSpaceSubsystem: AtomSpaceSubsystem
  cogServerSubsystem: CogServerSubsystem
  cogGMLSubsystem: CogGMLSubsystem
  cogSelfSubsystem: CogSelfSubsystem
  reasoningSubsystem: ReasoningSubsystem
  learningSubsystem: LearningSubsystem
  attentionSubsystem: AttentionSubsystem
  systemStatus: SystemStatus
  uptime: ‚Ñï  -- seconds
  lastHeartbeat: Timestamp
where
  -- System must have at least one AtomSpace instance
  #atomSpaceSubsystem.instances > 0
  
  -- CogServer must be running if system is operational
  systemStatus = OPERATIONAL ‚áí 
    cogServerSubsystem.server.serverState = RUNNING
  
  -- Uptime must be consistent with last heartbeat
  uptime ‚â• 0
  lastHeartbeat > 0
  
  -- CogSelf must be monitoring if autonomous mode is enabled
  cogSelfSubsystem.autonomousMode = true ‚áí
    cogSelfSubsystem.lastSelfImprovement > 0
  
  -- AtomSpace instances must be accessible via CogServer
  atomSpaceSubsystem.defaultInstance ‚àà 
    ran cogServerSubsystem.server.atomSpaces
end

SystemStatus ::= {INITIALIZING, OPERATIONAL, DEGRADED, MAINTENANCE, SHUTDOWN}

--------------------------------------------------------------------------------
-- SECTION 3: State Transition Constraints
--------------------------------------------------------------------------------

-- Initialization state
schema InitState
  OpenCogSystemState
where
  -- System starts in initializing status
  systemStatus = INITIALIZING
  
  -- No uptime initially
  uptime = 0
  
  -- Default AtomSpace must exist
  #atomSpaceSubsystem.instances = 1
  
  -- No active connections initially
  cogServerSubsystem.server.connections = ‚àÖ
  
  -- No active shards initially
  cogGMLSubsystem.coordinator.activeShards = ‚àÖ
end

-- Operational state
schema OperationalState
  OpenCogSystemState
where
  -- System is operational
  systemStatus = OPERATIONAL
  
  -- CogServer is running
  cogServerSubsystem.server.serverState = RUNNING
  
  -- At least default AtomSpace exists
  #atomSpaceSubsystem.instances ‚â• 1
  
  -- Heartbeat is recent (within last 60 seconds)
  -- Simplified: heartbeat exists
  lastHeartbeat > 0
end

-- Degraded state (some subsystems failing)
schema DegradedState
  OpenCogSystemState
where
  -- System is degraded
  systemStatus = DEGRADED
  
  -- Core AtomSpace must still be operational
  #atomSpaceSubsystem.instances ‚â• 1
  
  -- At least one subsystem has issues
  (cogServerSubsystem.server.serverState = ERROR ‚à®
   cogGMLSubsystem.microkernel.initialized = false ‚à®
   #cogSelfSubsystem.framework.goals = 0)
end

-- Shutdown state
schema ShutdownState
  OpenCogSystemState
where
  -- System is shutting down or shut down
  systemStatus = SHUTDOWN
  
  -- CogServer is stopped or stopping
  cogServerSubsystem.server.serverState ‚àà {STOPPED, STOPPING}
  
  -- No active connections
  cogServerSubsystem.server.connections = ‚àÖ
  
  -- No active shards
  cogGMLSubsystem.coordinator.activeShards = ‚àÖ
end

--------------------------------------------------------------------------------
-- SECTION 4: Subsystem Interaction Invariants
--------------------------------------------------------------------------------

-- Invariant: AtomSpace consistency across subsystems
invariant AtomSpaceConsistency
  ‚àÄ state: OpenCogSystemState ‚áí
    -- All reasoning operations reference valid atoms
    (‚àÄ rule: InferenceRule | 
       rule ‚àà state.reasoningSubsystem.plnEngine.ruleBase ‚áí
       (‚àÄ uuid: UUID | uuid ‚àà rule.premise ‚à™ {rule.conclusion} ‚áí
         uuid ‚àà dom state.atomSpaceSubsystem.instances
                    (state.atomSpaceSubsystem.defaultInstance).atoms))
    ‚àß
    -- All attention updates reference valid atoms
    (‚àÄ update: ImportanceUpdate |
       update ‚àà state.attentionSubsystem.importanceUpdates ‚áí
       update.atomID ‚àà dom state.atomSpaceSubsystem.instances
                         (state.atomSpaceSubsystem.defaultInstance).atoms)

-- Invariant: Shard-AtomSpace coordination
invariant ShardAtomSpaceCoordination
  ‚àÄ state: OpenCogSystemState;
    task: CognitiveTask |
    task ‚àà state.cogGMLSubsystem.microkernel.taskQueue ‚áí
    task.assignedShard ‚àà dom state.cogGMLSubsystem.coordinator.shards ‚àß
    -- Tasks must have access to AtomSpace
    state.atomSpaceSubsystem.defaultInstance ‚â† 0

-- Invariant: Network session consistency
invariant NetworkSessionConsistency
  ‚àÄ state: OpenCogSystemState;
    session: Session |
    session ‚àà ran state.cogServerSubsystem.server.sessions ‚áí
    -- Session must reference valid AtomSpace
    session.currentAtomSpace ‚àà dom state.atomSpaceSubsystem.instances ‚àß
    -- Session must have valid connection
    session.connectionID ‚àà dom state.cogServerSubsystem.server.connections

-- Invariant: Synergy level reflects component integration
invariant SynergyIntegration
  ‚àÄ state: OpenCogSystemState ‚áí
    state.cogSelfSubsystem.framework.synergyManager.overallSynergyLevel > 0 ‚áí
    -- Active components must exist
    #state.cogSelfSubsystem.framework.synergyManager.components > 1 ‚àß
    -- CogGML must have active shards
    #state.cogGMLSubsystem.coordinator.activeShards > 0 ‚àß
    -- AtomSpace must be operational
    state.atomSpaceSubsystem.defaultInstance ‚àà 
      dom state.atomSpaceSubsystem.instances

-- Invariant: Resource bounds
invariant ResourceBounds
  ‚àÄ state: OpenCogSystemState ‚áí
    -- Memory utilization should not exceed critical threshold
    state.cogGMLSubsystem.executionMetrics.memoryUtilization ‚â§ 0.95 ‚àß
    -- CPU utilization should be reasonable
    state.cogGMLSubsystem.executionMetrics.cpuUtilization ‚â§ 1.0 ‚àß
    -- Task queue should not grow unbounded
    #state.cogGMLSubsystem.microkernel.taskQueue ‚â§ 10000 ‚àß
    -- Request queue should not grow unbounded
    #state.cogServerSubsystem.requestQueue ‚â§ 10000

-- Invariant: Temporal consistency
invariant TemporalConsistency
  ‚àÄ state: OpenCogSystemState ‚áí
    -- Heartbeat must be recent relative to uptime
    state.lastHeartbeat > 0 ‚àß
    -- All subsystem timestamps must be monotonic
    (‚àÄ assessment: AGIAssessment |
       assessment ‚àà state.cogSelfSubsystem.assessmentHistory ‚áí
       assessment.timestamp ‚â§ state.lastHeartbeat)

--------------------------------------------------------------------------------
-- SECTION 5: State Aggregations and Derived Properties
--------------------------------------------------------------------------------

-- Function to calculate overall system health
function systemHealth(state: OpenCogSystemState): {r: ‚Ñù | 0 ‚â§ r ‚â§ 1}
  let atomspaceHealth = 
    if #state.atomSpaceSubsystem.instances > 0 then 1.0 else 0.0
  let networkHealth =
    if state.cogServerSubsystem.server.serverState = RUNNING then 1.0 else 0.0
  let shardHealth =
    (#state.cogGMLSubsystem.coordinator.activeShards / 
     max(#state.cogGMLSubsystem.shardPool, 1))
  let synergyHealth =
    state.cogSelfSubsystem.framework.synergyManager.overallSynergyLevel
  in
    (atomspaceHealth + networkHealth + shardHealth + synergyHealth) / 4.0
end

-- Function to calculate cognitive load
function cognitiveLoad(state: OpenCogSystemState): {r: ‚Ñù | 0 ‚â§ r ‚â§ 1}
  let taskLoad = #state.cogGMLSubsystem.microkernel.taskQueue /
                 max(state.cogGMLSubsystem.microkernel.maxConcurrentTasks, 1)
  let requestLoad = #state.cogServerSubsystem.requestQueue / 10000.0
  let memoryLoad = state.cogGMLSubsystem.executionMetrics.memoryUtilization
  in
    (taskLoad + requestLoad + memoryLoad) / 3.0
end

-- Function to check if system is healthy
function isHealthy(state: OpenCogSystemState): ùîπ
  systemHealth(state) ‚â• 0.7 ‚àß
  cognitiveLoad(state) ‚â§ 0.8 ‚àß
  state.systemStatus ‚àà {OPERATIONAL, MAINTENANCE}
end

-- Function to determine if autonomous improvement should trigger
function shouldTriggerImprovement(state: OpenCogSystemState): ùîπ
  state.cogSelfSubsystem.autonomousMode = true ‚àß
  state.cogSelfSubsystem.framework.overallAGIProgress < 1.0 ‚àß
  (state.lastHeartbeat - state.cogSelfSubsystem.lastSelfImprovement > 3600000)
  -- More than 1 hour since last improvement
end

--------------------------------------------------------------------------------
-- End of System State Specification
--------------------------------------------------------------------------------
