--------------------------------------------------------------------------------
-- OpenCog Collection - Data Layer Formal Specification (Z++)
-- 
-- This specification formalizes the data models and invariants of the core
-- AtomSpace hypergraph database and related data structures.
--
-- Author: Formal Methods Agent
-- Date: 2025-11-06
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- SECTION 1: Basic Types and Constants
--------------------------------------------------------------------------------

-- Basic integer type for identifiers
UUID ::= â„•

-- Bounded natural numbers for counts
AtomCount ::= {n: â„• | n â‰¥ 0 âˆ§ n â‰¤ 1000000000}
ShardCount ::= {n: â„• | n â‰¥ 0 âˆ§ n â‰¤ 1000}

-- String representation (sequences of characters)
String ::= seq Char

-- Atom type identifiers (enumeration represented as naturals)
AtomType ::= â„•

-- Truth value components
TruthValueStrength ::= {r: â„ | 0 â‰¤ r â‰¤ 1}
TruthValueConfidence ::= {r: â„ | 0 â‰¤ r â‰¤ 1}

-- Attention values
STI ::= â„¤  -- Short-term importance
LTI ::= â„¤  -- Long-term importance
VLTI ::= {b: ğ”¹}  -- Very long-term importance (boolean)

-- Network connection identifiers
ConnectionID ::= â„•
SessionID ::= â„•
PortNumber ::= {n: â„• | 1024 â‰¤ n â‰¤ 65535}

-- Timestamps (Unix epoch milliseconds)
Timestamp ::= â„•

-- Message priorities
MessagePriority ::= {LOW, NORMAL, HIGH, URGENT}

-- Message types
MessageType ::= {DATA_TRANSFER, CONTROL, QUERY, RESPONSE, EVENT}

--------------------------------------------------------------------------------
-- SECTION 2: AtomSpace Core Data Model
--------------------------------------------------------------------------------

-- Basic Atom structure
-- An Atom is the fundamental unit in the hypergraph database
schema Atom
  uuid: UUID
  atomType: AtomType
  name: String
  truthValue: TruthValue
  attentionValue: AttentionValue
  incomingSet: â„™ UUID  -- Set of Atoms that reference this Atom
  values: KeyValueStore  -- Mutable key-value storage
where
  -- UUID must be unique (enforced at AtomSpace level)
  -- atomType must be a valid registered type
  -- name is used for Node atoms, empty for Link atoms
  atomType âˆˆ ValidAtomTypes
end

-- Link extends Atom with outgoing set
schema Link extends Atom
  outgoingSet: seq UUID  -- Ordered list of target Atoms
where
  -- Link must have at least one outgoing atom
  #outgoingSet > 0
  -- All outgoing atoms must exist (referential integrity)
  âˆ€ targetUUID: UUID | targetUUID âˆˆ outgoingSet â‡’ 
    targetUUID âˆˆ atomSpaceUUIDs
end

-- Node extends Atom (no outgoing set, identified by name)
schema Node extends Atom
where
  -- Nodes are identified by (type, name) tuple
  -- Empty outgoing set (implicit)
  name â‰  ""
end

-- Truth Value representation (Simple/Confidence model)
schema TruthValue
  strength: TruthValueStrength
  confidence: TruthValueConfidence
  count: â„•  -- Evidence count
where
  -- Basic probability constraints
  0 â‰¤ strength â‰¤ 1
  0 â‰¤ confidence â‰¤ 1
  count â‰¥ 0
end

-- Attention Value for Economic Attention Networks (ECAN)
schema AttentionValue
  sti: STI  -- Short-term importance
  lti: LTI  -- Long-term importance
  vlti: VLTI  -- Very long-term importance flag
where
  -- Attention values can be negative (debt) or positive (credit)
  true  -- No specific invariants beyond type constraints
end

-- Key-Value store for mutable data attached to Atoms
schema KeyValueStore
  entries: Key â‡¸ Value  -- Partial function from keys to values
where
  -- Keys must be valid Atoms (typically Nodes)
  dom entries âŠ† atomSpaceUUIDs
end

schema Key
  keyAtom: UUID
where
  keyAtom âˆˆ atomSpaceUUIDs
end

schema Value
  valueType: ValueType
  data: ValueData
end

ValueType ::= {FLOAT_VALUE, STRING_VALUE, LINK_VALUE, BOOL_VALUE}

ValueData ::= FloatVector | String | seq UUID | ğ”¹

FloatVector ::= seq â„

-- Type system for Atoms
schema AtomTypeNode
  typeID: AtomType
  typeName: String
  parent: AtomType  -- Inheritance hierarchy
  isLink: ğ”¹  -- True if this is a Link type
where
  -- Root type has no parent (represented as self-reference)
  typeID = parent âˆ¨ parent âˆˆ ValidAtomTypes
  -- Type names must be unique
  typeName â‰  ""
end

ValidAtomTypes: â„™ AtomType

--------------------------------------------------------------------------------
-- SECTION 3: AtomSpace State Model
--------------------------------------------------------------------------------

-- AtomSpace: The central hypergraph database
schema AtomSpace
  atoms: UUID â‡¸ Atom  -- Map from UUID to Atom
  typeIndex: AtomType â‡¸ â„™ UUID  -- Index atoms by type
  nameIndex: (AtomType Ã— String) â‡¸ UUID  -- Index nodes by (type, name)
  incomingIndex: UUID â‡¸ â„™ UUID  -- Reverse index for links
  typeSystem: AtomType â‡¸ AtomTypeNode  -- Type hierarchy
  readOnly: ğ”¹  -- Read-only mode flag
  refCount: UUID â‡¸ â„•  -- Reference counts for garbage collection
where
  -- All atoms in indices must exist in main atom table
  âˆ€ t: AtomType; uuids: â„™ UUID | (t, uuids) âˆˆ typeIndex â‡’ uuids âŠ† dom atoms
  
  -- Name index integrity: all indexed UUIDs must exist
  âˆ€ key: (AtomType Ã— String); uuid: UUID | (key, uuid) âˆˆ nameIndex â‡’ 
    uuid âˆˆ dom atoms
  
  -- Incoming index integrity
  âˆ€ uuid: UUID; incoming: â„™ UUID | (uuid, incoming) âˆˆ incomingIndex â‡’
    uuid âˆˆ dom atoms âˆ§ incoming âŠ† dom atoms
  
  -- Every atom must have a valid type
  âˆ€ uuid: UUID; atom: Atom | (uuid, atom) âˆˆ atoms â‡’
    atom.atomType âˆˆ dom typeSystem
  
  -- Reference count invariant: atoms with refCount > 0 must exist
  dom refCount âŠ† dom atoms
  
  -- Bidirectional incoming set consistency
  âˆ€ linkUUID: UUID; link: Link | (linkUUID, link) âˆˆ atoms â‡’
    âˆ€ targetUUID: UUID | targetUUID âˆˆ link.outgoingSet â‡’
      linkUUID âˆˆ atoms(targetUUID).incomingSet
end

-- AtomTable: Low-level storage mechanism
schema AtomTable
  uuidCounter: UUID  -- Next available UUID
  storage: UUID â‡¸ Atom
  size: AtomCount
where
  -- UUID counter must be greater than all assigned UUIDs
  âˆ€ uuid: UUID | uuid âˆˆ dom storage â‡’ uuid < uuidCounter
  
  -- Size must match actual storage
  size = #(dom storage)
  
  -- No duplicate UUIDs (ensured by map structure)
end

--------------------------------------------------------------------------------
-- SECTION 4: CogServer Network State Model
--------------------------------------------------------------------------------

-- Network connection state
schema Connection
  connectionID: ConnectionID
  sessionID: SessionID
  clientAddress: String  -- IP:Port
  protocol: Protocol
  state: ConnectionState
  authenticatedUser: String  -- Empty if not authenticated
  createdAt: Timestamp
  lastActivityAt: Timestamp
where
  -- Last activity must be after or equal to creation
  lastActivityAt â‰¥ createdAt
  
  -- Authenticated connections must have non-empty user
  state = AUTHENTICATED â‡’ authenticatedUser â‰  ""
end

Protocol ::= {TCP_BINARY, WEBSOCKET, HTTP}

ConnectionState ::= {CONNECTING, AUTHENTICATING, AUTHENTICATED, 
                     EXECUTING, ERROR, DISCONNECTING}

-- Session state for interactive shells
schema Session
  sessionID: SessionID
  connectionID: ConnectionID
  shellType: ShellType
  environment: Environment  -- Scheme/Python interpreter state
  commandHistory: seq String
  currentAtomSpace: UUID  -- Reference to AtomSpace instance
where
  -- Session must have valid connection
  connectionID âˆˆ activeConnections
  
  -- Command history is append-only
  #commandHistory â‰¥ 0
end

ShellType ::= {SCHEME_SHELL, PYTHON_SHELL, JSON_API, SEXPR_API}

-- Environment: Interpreter state (simplified abstraction)
schema Environment
  variables: String â‡¸ Value
  modules: â„™ String  -- Loaded modules
where
  -- Module names must be non-empty
  âˆ€ m: String | m âˆˆ modules â‡’ m â‰  ""
end

-- CogServer overall state
schema CogServer
  connections: ConnectionID â‡¸ Connection
  sessions: SessionID â‡¸ Session
  listenPorts: â„™ PortNumber
  atomSpaces: UUID â‡¸ AtomSpace  -- Multiple AtomSpace instances
  defaultAtomSpace: UUID
  serverState: ServerState
where
  -- Default AtomSpace must exist
  defaultAtomSpace âˆˆ dom atomSpaces
  
  -- All sessions must reference existing connections
  âˆ€ sid: SessionID; sess: Session | (sid, sess) âˆˆ sessions â‡’
    sess.connectionID âˆˆ dom connections
  
  -- All session AtomSpaces must exist
  âˆ€ sid: SessionID; sess: Session | (sid, sess) âˆˆ sessions â‡’
    sess.currentAtomSpace âˆˆ dom atomSpaces
  
  -- Server must be listening if running
  serverState = RUNNING â‡’ listenPorts â‰  âˆ…
end

ServerState ::= {STOPPED, STARTING, RUNNING, STOPPING, ERROR}

activeConnections: â„™ ConnectionID

--------------------------------------------------------------------------------
-- SECTION 5: CogGML Microkernel Data Model
--------------------------------------------------------------------------------

-- Cognitive Shard: Self-aware processing unit
schema CognitiveShard
  shardID: UUID
  name: String
  purpose: String
  state: ShardState
  selfAwarenessMetrics: SelfAwarenessMetrics
  messageQueue: seq ShardMessage
  processCallback: ProcessCallback  -- Function reference
  activatedAt: Timestamp
  deactivatedAt: Timestamp  -- 0 if currently active
where
  -- Name and purpose must be non-empty
  name â‰  "" âˆ§ purpose â‰  ""
  
  -- Temporal consistency
  state = ACTIVE â‡’ deactivatedAt = 0
  state = INACTIVE â‡’ activatedAt â‰¤ deactivatedAt
  
  -- Active shards must have at least been activated once
  state = ACTIVE â‡’ activatedAt > 0
end

ShardState ::= {INACTIVE, ACTIVATING, ACTIVE, PROCESSING, 
                SELF_MONITORING, DEACTIVATING}

-- Self-awareness metrics for cognitive shards
schema SelfAwarenessMetrics
  taskCompletionRate: {r: â„ | 0 â‰¤ r â‰¤ 1}
  averageResponseTime: â„  -- milliseconds
  errorRate: {r: â„ | 0 â‰¤ r â‰¤ 1}
  selfAssessmentScore: {r: â„ | 0 â‰¤ r â‰¤ 1}
  lastReflectionTime: Timestamp
where
  -- Response time must be non-negative
  averageResponseTime â‰¥ 0
  
  -- All metrics are bounded
  0 â‰¤ taskCompletionRate â‰¤ 1
  0 â‰¤ errorRate â‰¤ 1
  0 â‰¤ selfAssessmentScore â‰¤ 1
end

ProcessCallback ::= Function  -- Abstract function type

-- Inter-shard messages
schema ShardMessage
  messageID: UUID
  senderID: UUID
  receiverID: UUID
  messageType: MessageType
  priority: MessagePriority
  payload: String
  sentAt: Timestamp
  deliveredAt: Timestamp  -- 0 if not delivered
where
  -- Sender and receiver must be different (no self-messages)
  senderID â‰  receiverID
  
  -- Delivered timestamp must be after sent timestamp
  deliveredAt = 0 âˆ¨ deliveredAt â‰¥ sentAt
  
  -- Sender and receiver must be valid shards
  senderID âˆˆ registeredShards
  receiverID âˆˆ registeredShards
end

registeredShards: â„™ UUID

-- Shard Coordinator state
schema ShardCoordinator
  shards: UUID â‡¸ CognitiveShard
  activeShards: â„™ UUID
  messageRouter: MessageRouter
  synergyLevel: {r: â„ | 0 â‰¤ r â‰¤ 1}
  coordinationMetrics: CoordinationMetrics
where
  -- Active shards must be registered
  activeShards âŠ† dom shards
  
  -- Active shards must have ACTIVE state
  âˆ€ sid: UUID | sid âˆˆ activeShards â‡’ shards(sid).state = ACTIVE
  
  -- Synergy level is calculated from active interactions
  activeShards â‰  âˆ… â‡’ synergyLevel > 0
end

-- Message routing state
schema MessageRouter
  routingTable: UUID â‡¸ UUID  -- Receiver to current handler mapping
  messageQueue: seq ShardMessage  -- Pending messages
  deliveryMetrics: DeliveryMetrics
where
  -- All receivers in routing table must be registered shards
  ran routingTable âŠ† registeredShards
end

-- Coordination performance metrics
schema CoordinationMetrics
  totalMessagesSent: â„•
  totalMessagesDelivered: â„•
  averageDeliveryTime: â„  -- milliseconds
  coordinationCycles: â„•
where
  -- Delivered messages cannot exceed sent messages
  totalMessagesDelivered â‰¤ totalMessagesSent
  
  -- Average delivery time is non-negative
  averageDeliveryTime â‰¥ 0
  
  -- Coordination cycles must be non-negative
  coordinationCycles â‰¥ 0
end

schema DeliveryMetrics
  successfulDeliveries: â„•
  failedDeliveries: â„•
  averageLatency: â„  -- milliseconds
where
  averageLatency â‰¥ 0
end

--------------------------------------------------------------------------------
-- SECTION 6: CogSelf AGI Framework Data Model
--------------------------------------------------------------------------------

-- AGI Goal representation
schema AGIGoal
  goalID: UUID
  name: String
  description: String
  progress: {r: â„ | 0 â‰¤ r â‰¤ 1}  -- 0 to 1
  priority: {p: â„• | 1 â‰¤ p â‰¤ 10}
  milestones: seq Milestone
where
  -- Goal must have a name and description
  name â‰  "" âˆ§ description â‰  ""
  
  -- Progress must be consistent with milestones
  #milestones > 0 â‡’ 
    progress = (# {m: Milestone | m âˆˆ milestones âˆ§ m.completed}) / #milestones
end

schema Milestone
  milestoneID: UUID
  description: String
  completed: ğ”¹
  completedAt: Timestamp  -- 0 if not completed
where
  completed = true â‡’ completedAt > 0
  completed = false â‡’ completedAt = 0
end

-- Synergy Manager state
schema SynergyManager
  components: â„™ ComponentID
  interactionMatrix: ComponentID Ã— ComponentID â‡¸ â„  -- Synergy scores
  overallSynergyLevel: {r: â„ | 0 â‰¤ r â‰¤ 1}
  lastOptimization: Timestamp
where
  -- Interaction matrix must be symmetric
  âˆ€ c1, c2: ComponentID | (c1, c2) âˆˆ dom interactionMatrix â‡’
    (c2, c1) âˆˆ dom interactionMatrix âˆ§
    interactionMatrix(c1, c2) = interactionMatrix(c2, c1)
  
  -- All components in matrix must be registered
  dom interactionMatrix âŠ† components Ã— components
  
  -- Overall synergy is aggregate of interactions
  #components > 1 â‡’ overallSynergyLevel > 0
end

ComponentID ::= {COGGML, ACCELERATOR, AGENTIC, PLN, URE, MOSES}

-- CogSelf main framework state
schema CogSelf
  goals: UUID â‡¸ AGIGoal
  synergyManager: SynergyManager
  shardCoordinator: ShardCoordinator
  improvementPlans: seq ImprovementPlan
  overallAGIProgress: {r: â„ | 0 â‰¤ r â‰¤ 1}
where
  -- At least one AGI goal must be defined
  #goals > 0
  
  -- Overall progress is weighted average of goal progress
  overallAGIProgress = 
    (Î£ {g: AGIGoal | g âˆˆ ran goals} Â· g.progress * g.priority) /
    (Î£ {g: AGIGoal | g âˆˆ ran goals} Â· g.priority)
  
  -- Synergy level influences AGI progress
  synergyManager.overallSynergyLevel > 0
end

-- Improvement plan for autonomous self-improvement
schema ImprovementPlan
  planID: UUID
  targetComponent: ComponentID
  description: String
  expectedImprovement: {r: â„ | 0 â‰¤ r â‰¤ 1}
  status: PlanStatus
  createdAt: Timestamp
  implementedAt: Timestamp  -- 0 if not implemented
where
  status = IMPLEMENTED â‡’ implementedAt > createdAt
  status â‰  IMPLEMENTED â‡’ implementedAt = 0
end

PlanStatus ::= {PROPOSED, APPROVED, IMPLEMENTING, IMPLEMENTED, REJECTED}

--------------------------------------------------------------------------------
-- SECTION 7: Storage Backend Data Model
--------------------------------------------------------------------------------

-- Storage Node abstraction
schema StorageNode
  storageID: UUID
  backendType: BackendType
  connectionString: String
  connected: ğ”¹
  readOnly: ğ”¹
  statistics: StorageStatistics
where
  -- Connected storage must have valid connection string
  connected = true â‡’ connectionString â‰  ""
end

BackendType ::= {ROCKSDB, POSTGRESQL, COG_DISTRIBUTED, IN_MEMORY}

-- Storage operation statistics
schema StorageStatistics
  atomsStored: â„•
  atomsFetched: â„•
  atomsDeleted: â„•
  totalReads: â„•
  totalWrites: â„•
  averageReadLatency: â„  -- milliseconds
  averageWriteLatency: â„  -- milliseconds
where
  -- Fetched atoms must be non-zero if storage is used
  totalReads â‰¥ atomsFetched
  
  -- Latencies must be non-negative
  averageReadLatency â‰¥ 0
  averageWriteLatency â‰¥ 0
end

--------------------------------------------------------------------------------
-- SECTION 8: Global Invariants
--------------------------------------------------------------------------------

-- Global system invariant: AtomSpace UUID uniqueness across all instances
invariant GlobalUUIDUniqueness
  âˆ€ as1, as2: AtomSpace | as1 â‰  as2 â‡’
    dom as1.atoms âˆ© dom as2.atoms = âˆ…

-- Global invariant: All atom references must resolve
invariant ReferentialIntegrity
  âˆ€ as: AtomSpace; link: Link | link âˆˆ ran as.atoms â‡’
    âˆ€ uuid: UUID | uuid âˆˆ link.outgoingSet â‡’ uuid âˆˆ dom as.atoms

-- Global invariant: Type system must be acyclic (no circular inheritance)
invariant TypeHierarchyAcyclic
  âˆ€ as: AtomSpace; t: AtomType | t âˆˆ dom as.typeSystem â‡’
    Â¬ (âˆƒ chain: seq AtomType | 
       chainâ‚€ = t âˆ§ 
       (âˆ€ i: â„• | i < #chain - 1 â‡’ 
         as.typeSystem(chaináµ¢).parent = chaináµ¢â‚Šâ‚) âˆ§
       chainâ‚#chain-1â‚ = t)

-- Global invariant: Shard messages must be deliverable
invariant MessageDeliverability
  âˆ€ coord: ShardCoordinator; msg: ShardMessage | 
    msg âˆˆ coord.messageRouter.messageQueue â‡’
    msg.receiverID âˆˆ dom coord.shards

-- Global invariant: Active connections must have valid sessions
invariant ConnectionSessionConsistency
  âˆ€ cs: CogServer; conn: Connection | 
    conn âˆˆ ran cs.connections âˆ§ conn.state = AUTHENTICATED â‡’
    (âˆƒ sess: Session | sess âˆˆ ran cs.sessions âˆ§ 
                       sess.connectionID = conn.connectionID)

--------------------------------------------------------------------------------
-- End of Data Model Specification
--------------------------------------------------------------------------------
