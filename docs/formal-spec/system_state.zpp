(*
 * AGI-OS System State - Z++ Formal Specification
 * 
 * This specification formalizes the overall system state of AGI-OS,
 * including all cognitive components, microkernel state, OS services,
 * and their interactions.
 * 
 * Author: AGI-OS Development Team
 * Date: December 12, 2025
 * Version: 1.0
 *)

(* Import data model *)
include "data_model.zpp"

(* ========================================================================
 * LAYER 1: MICROKERNEL STATE (COGNUMACH)
 * ======================================================================== *)

(*
 * CogNumach microkernel manages low-level system resources
 * with cognitive awareness
 *)

[ProcessID]
ProcessID == ‚Ñï‚ÇÅ

[PortID]
PortID == ‚Ñï‚ÇÅ

[MemoryRegionID]
MemoryRegionID == ‚Ñï‚ÇÅ

schema ProcessState
  pid: ProcessID
  process_name: AtomName
  parent_pid: ProcessID
  state: AtomName         (* "running", "blocked", "zombie", etc. *)
  priority: ‚Ñï             (* Scheduler priority 0-255 *)
  cpu_time: ‚Ñï             (* CPU time used in microseconds *)
  memory_usage: ‚Ñï         (* Memory usage in bytes *)
  sti_value: AttentionValue  (* Cognitive STI for scheduling *)
where
  pid > 0
  priority ‚â§ 255
  (* Parent process must exist or be init (pid 1) *)
  parent_pid > 0
  (* STI influences scheduling decisions *)
  sti_value ‚àà ‚Ñ§
end

schema MemoryRegion
  region_id: MemoryRegionID
  start_address: ‚Ñï
  size: ‚Ñï‚ÇÅ
  owner_pid: ProcessID
  permissions: AtomName   (* "r", "w", "x" combinations *)
  is_shared: ùîπ
where
  region_id > 0
  size > 0
  (* Memory regions don't wrap around *)
  start_address + size > start_address
end

schema IPCPort
  port_id: PortID
  owner_pid: ProcessID
  receive_right: ùîπ       (* Can receive messages *)
  send_right: ùîπ          (* Can send messages *)
  queue_limit: ‚Ñï‚ÇÅ
  current_queue_size: ‚Ñï
where
  port_id > 0
  owner_pid > 0
  (* Queue doesn't exceed limit *)
  current_queue_size ‚â§ queue_limit
  (* Must have at least one right *)
  receive_right ‚à® send_right
end

schema CogNumachState
  processes: ProcessID ‚Ü¶ ProcessState
  memory_regions: MemoryRegionID ‚Ü¶ MemoryRegion
  ports: PortID ‚Ü¶ IPCPort
  active_pid: ProcessID      (* Currently executing process *)
  cpu_count: ‚Ñï‚ÇÅ
  total_memory: ‚Ñï‚ÇÅ
  free_memory: ‚Ñï
where
  (* Active process must exist *)
  active_pid ‚àà dom processes
  
  (* Init process always exists *)
  1 ‚àà dom processes
  
  (* Memory regions don't overlap *)
  ‚àÄ r1, r2: ran memory_regions | r1 ‚â† r2 ‚Ä¢
    (r1.start_address + r1.size ‚â§ r2.start_address) ‚à®
    (r2.start_address + r2.size ‚â§ r1.start_address)
  
  (* Free memory is consistent *)
  free_memory ‚â§ total_memory
  
  (* Total allocated memory doesn't exceed total memory *)
  (‚àë r: ran memory_regions ‚Ä¢ r.size) ‚â§ total_memory - free_memory
end

(* ========================================================================
 * LAYER 2: OPERATING SYSTEM STATE (HURDCOG)
 * ======================================================================== *)

(*
 * HurdCog OS manages translators, file systems, and services
 * with cognitive extensions
 *)

[TranslatorID]
TranslatorID == ‚Ñï‚ÇÅ

[FileSystemID]
FileSystemID == ‚Ñï‚ÇÅ

[InodeNumber]
InodeNumber == ‚Ñï

schema Translator
  translator_id: TranslatorID
  translator_type: AtomName  (* "ext2fs", "tmpfs", "ftpfs", etc. *)
  mount_point: AtomName
  backing_pid: ProcessID      (* Process implementing translator *)
  is_active: ùîπ
  read_only: ùîπ
where
  translator_id > 0
  backing_pid > 0
end

schema FileDescriptor
  fd_number: ‚Ñï
  inode: InodeNumber
  position: ‚Ñï              (* Current read/write position *)
  flags: AtomName          (* "O_RDONLY", "O_WRONLY", "O_RDWR", etc. *)
  owner_pid: ProcessID
where
  fd_number ‚â• 0            (* 0=stdin, 1=stdout, 2=stderr *)
  position ‚â• 0
  owner_pid > 0
end

schema FileSystemEntry
  inode: InodeNumber
  path: AtomName
  entry_type: AtomName     (* "file", "directory", "symlink", etc. *)
  size: ‚Ñï
  permissions: ‚Ñï           (* Unix-style permissions *)
  owner_pid: ProcessID
  modified_time: Timestamp
where
  inode ‚â• 0
  permissions ‚â§ 777‚Çà       (* Octal permissions *)
  owner_pid > 0
end

schema CognitiveCache
  cache_id: ‚Ñï‚ÇÅ
  cached_inodes: ‚Ñô InodeNumber
  access_frequency: InodeNumber ‚Ü¶ ‚Ñï  (* Access count per inode *)
  sti_scores: InodeNumber ‚Ü¶ AttentionValue
  max_cache_size: ‚Ñï‚ÇÅ
where
  (* Cached inodes track access patterns *)
  dom access_frequency = cached_inodes
  dom sti_scores = cached_inodes
  
  (* Cache size is bounded *)
  #cached_inodes ‚â§ max_cache_size
  
  (* Frequently accessed files have higher STI *)
  ‚àÄ i: cached_inodes ‚Ä¢
    sti_scores(i) ‚â• 0 ‚üπ access_frequency(i) > 0
end

schema HurdCogState
  translators: TranslatorID ‚Ü¶ Translator
  file_descriptors: ‚Ñô FileDescriptor
  file_system: InodeNumber ‚Ü¶ FileSystemEntry
  cognitive_cache: CognitiveCache
  root_inode: InodeNumber
where
  (* Root filesystem always exists *)
  root_inode ‚àà dom file_system
  file_system(root_inode).entry_type = "directory"
  
  (* All translators backed by valid processes *)
  ‚àÄ t: ran translators | t.is_active ‚Ä¢
    t.backing_pid > 0
  
  (* File descriptors reference valid inodes *)
  ‚àÄ fd: file_descriptors ‚Ä¢
    fd.inode ‚àà dom file_system
  
  (* Cached inodes must exist in file system *)
  cognitive_cache.cached_inodes ‚äÜ dom file_system
end

(* ========================================================================
 * LAYER 3: COGNITIVE FRAMEWORK STATE (OPENCOG)
 * ======================================================================== *)

(*
 * OpenCog cognitive framework manages reasoning, learning, and attention
 *)

schema CogUtilState
  logger_level: AtomName    (* "DEBUG", "INFO", "WARN", "ERROR" *)
  random_seed: ‚Ñï
  config_params: AtomName ‚Ü¶ AtomName
where
  logger_level ‚àà {"DEBUG", "INFO", "WARN", "ERROR"}
end

schema AtomSpaceState
  extends AtomSpace
  attention_focus: AttentionalFocus
  forgetting_policy: ForgettingPolicy
  query_cache: Pattern ‚Ü¶ ‚Ñô (VariableID ‚Ü¶ AtomID)
where
  (* Attentional focus is consistent with atomspace *)
  attention_focus.atomspace = self
  
  (* Query cache contains valid solutions *)
  ‚àÄ p: dom query_cache ‚Ä¢
    ‚àÄ solution: query_cache(p) ‚Ä¢
      dom solution = {v: p.variables ‚Ä¢ v.var_id}
end

schema CogServerState
  server_id: ‚Ñï‚ÇÅ
  port_number: ‚Ñï‚ÇÅ
  is_listening: ùîπ
  connected_clients: ‚Ñô (AtomName √ó ‚Ñï)  (* (IP address, client ID) pairs *)
  atomspace: AtomSpaceState
  request_count: ‚Ñï
  last_request_time: Timestamp
where
  server_id > 0
  (* Standard ports: 17001 for telnet, 18080 for HTTP *)
  port_number ‚àà 1024..65535
  
  (* Can't have clients without listening *)
  #connected_clients > 0 ‚üπ is_listening
  
  (* Request count only increases *)
  request_count ‚â• 0
end

(* ========================================================================
 * REASONING SUBSYSTEM STATE
 * ======================================================================== *)

schema PLNState
  rule_base: ‚Ñô AtomID         (* Set of inference rules *)
  inference_depth: ‚Ñï           (* Maximum inference depth *)
  confidence_threshold: Confidence
  active_inferences: ‚Ñô AtomID  (* Currently active inference chains *)
  inference_count: ‚Ñï
where
  (* Rules must be in atomspace *)
  true  (* Simplified - would reference parent atomspace *)
  
  (* Depth bounded to prevent infinite recursion *)
  inference_depth ‚â§ 100
  
  (* Confidence threshold controls inference *)
  confidence_threshold > 0.0
  
  (* Inference count increases monotonically *)
  inference_count ‚â• 0
end

schema UREState
  forward_rules: ‚Ñô AtomID
  backward_rules: ‚Ñô AtomID
  max_iterations: ‚Ñï‚ÇÅ
  current_iteration: ‚Ñï
where
  (* URE maintains separate forward and backward rule sets *)
  forward_rules ‚à© backward_rules = ‚àÖ  (* Rules are directional *)
  
  (* Iteration control *)
  current_iteration ‚â§ max_iterations
  max_iterations ‚â§ 10000  (* Practical upper bound *)
end

(* ========================================================================
 * LEARNING SUBSYSTEM STATE
 * ======================================================================== *)

schema MOSESState
  population_size: ‚Ñï‚ÇÅ
  max_generations: ‚Ñï‚ÇÅ
  current_generation: ‚Ñï
  best_fitness: ‚Ñù
  population: seq AtomID      (* Current population of programs *)
  fitness_cache: AtomID ‚Ü¶ ‚Ñù
where
  (* Population size is fixed *)
  #population = population_size
  
  (* Generation count *)
  current_generation ‚â§ max_generations
  
  (* Best fitness is from current population *)
  best_fitness ‚àà ran fitness_cache
  
  (* All population members have fitness scores *)
  dom fitness_cache ‚äá elems population
end

schema PatternMinerState
  min_support: ‚Ñï‚ÇÅ             (* Minimum pattern frequency *)
  max_conjuncts: ‚Ñï‚ÇÅ           (* Maximum pattern complexity *)
  discovered_patterns: ‚Ñô AtomID
  pattern_frequency: AtomID ‚Ü¶ ‚Ñï
where
  (* Support threshold *)
  min_support ‚â• 2
  
  (* Complexity bounds *)
  max_conjuncts ‚â• 1 ‚àß max_conjuncts ‚â§ 10
  
  (* All discovered patterns have frequency *)
  dom pattern_frequency = discovered_patterns
  
  (* All patterns meet minimum support *)
  ‚àÄ p: discovered_patterns ‚Ä¢
    pattern_frequency(p) ‚â• min_support
end

schema ECANState
  sti_funds_total: AttentionValue
  lti_funds_total: AttentionValue
  min_sti: AttentionValue
  max_sti: AttentionValue
  attention_focus: AttentionalFocus
  rent_collection_rate: ‚Ñù      (* Rate of STI decay *)
  update_count: ‚Ñï
where
  (* Attention economy conservation *)
  sti_funds_total > 0
  lti_funds_total > 0
  
  (* STI bounds *)
  min_sti ‚â§ max_sti
  
  (* Rent collection rate *)
  0.0 < rent_collection_rate ‚àß rent_collection_rate ‚â§ 1.0
  
  (* Update count tracks attention spreads *)
  update_count ‚â• 0
end

(* ========================================================================
 * LAYER 4: AI DEVELOPMENT TOOLS (COGBOLT)
 * ======================================================================== *)

schema CogBoltState
  workspace_path: AtomName
  open_files: ‚Ñô AtomName
  active_file: AtomName
  cursor_position: (‚Ñï √ó ‚Ñï)    (* (line, column) *)
  undo_stack_depth: ‚Ñï
  is_ai_enabled: ùîπ
  llm_model_loaded: ùîπ
where
  (* Active file must be in open files *)
  active_file ‚àà open_files ‚à® open_files = ‚àÖ
  
  (* Cursor position is valid *)
  let (line, col) = cursor_position in
    line ‚â• 1 ‚àß col ‚â• 1
  
  (* AI features require model *)
  is_ai_enabled ‚üπ llm_model_loaded
end

(* ========================================================================
 * COMPLETE SYSTEM STATE
 * ======================================================================== *)

schema AGIOSSystemState
  (* Layer 1: Microkernel *)
  cognumach: CogNumachState
  
  (* Layer 2: Operating System *)
  hurdcog: HurdCogState
  
  (* Layer 3: Cognitive Framework *)
  cogutil: CogUtilState
  atomspace: AtomSpaceState
  cogserver: CogServerState
  
  (* Reasoning *)
  pln: PLNState
  ure: UREState
  
  (* Learning *)
  moses: MOSESState
  pattern_miner: PatternMinerState
  ecan: ECANState
  
  (* Layer 4: Development Tools *)
  cogbolt: CogBoltState
  
  (* System-wide *)
  boot_time: Timestamp
  uptime: ‚Ñï               (* Seconds since boot *)
  current_time: Timestamp
  
  (* Task scheduling *)
  task_queue: TaskQueue
  event_queue: EventQueue
where
  (* CogServer uses the same atomspace *)
  cogserver.atomspace = atomspace
  
  (* ECAN manages attention in atomspace *)
  ecan.attention_focus = atomspace.attention_focus
  
  (* Uptime is consistent *)
  current_time = boot_time + uptime
  
  (* HurdCog translators run as CogNumach processes *)
  ‚àÄ t: ran hurdcog.translators | t.is_active ‚Ä¢
    t.backing_pid ‚àà dom cognumach.processes
  
  (* CogServer runs as a CogNumach process *)
  ‚àÉ pid: dom cognumach.processes ‚Ä¢
    cognumach.processes(pid).process_name = "cogserver"
end

(* ========================================================================
 * INITIAL STATE
 * ======================================================================== *)

schema InitialState
  extends AGIOSSystemState
where
  (* Boot phase complete *)
  uptime > 0
  
  (* Essential processes running *)
  1 ‚àà dom cognumach.processes  (* init *)
  #cognumach.processes ‚â• 3      (* init + basic services *)
  
  (* Root filesystem mounted *)
  hurdcog.root_inode ‚àà dom hurdcog.file_system
  
  (* AtomSpace initialized *)
  atomspace.atom_count ‚â• 0
  
  (* CogServer ready *)
  cogserver.is_listening
  
  (* Event and task queues initialized *)
  #task_queue.tasks ‚â• 0
  #event_queue.events ‚â• 0
end

(* ========================================================================
 * STEADY STATE INVARIANTS
 * ======================================================================== *)

schema SteadyStateInvariant
  state: AGIOSSystemState
where
  (* Memory consistency *)
  cognumach.free_memory ‚â• 0
  
  (* AtomSpace consistency *)
  ‚àÄ aid: dom state.atomspace.atoms | state.atomspace.atoms(aid) ‚àà Link ‚Ä¢
    ‚àÄ out_id: state.atomspace.atoms(aid).outgoing ‚Ä¢
      out_id ‚àà dom state.atomspace.atoms
  
  (* Attention conservation *)
  let total_sti = (‚àë aid: dom state.atomspace.atoms ‚Ä¢ 
                    state.atomspace.atoms(aid).attention_value.sti.sti) in
    total_sti ‚â§ state.ecan.sti_funds_total
  
  (* Task queue bounded *)
  #state.task_queue.tasks ‚â§ state.task_queue.max_size
  
  (* File descriptor consistency *)
  ‚àÄ fd: state.hurdcog.file_descriptors ‚Ä¢
    fd.owner_pid ‚àà dom state.cognumach.processes
  
  (* No orphan processes (except init children) *)
  ‚àÄ pid: dom state.cognumach.processes | pid ‚â† 1 ‚Ä¢
    state.cognumach.processes(pid).parent_pid ‚àà dom state.cognumach.processes
end

(* ========================================================================
 * DEGRADED STATE
 * ======================================================================== *)

(*
 * System can operate in degraded mode if components fail
 *)

schema DegradedState
  state: AGIOSSystemState
  failed_components: ‚Ñô AtomName
  degradation_level: ‚Ñï    (* 0=normal, 1=minor, 2=major, 3=critical *)
where
  (* Level based on failed components *)
  degradation_level ‚àà 0..3
  
  (* Core components must be operational *)
  "cognumach" ‚àâ failed_components  (* Microkernel must work *)
  "atomspace" ‚àâ failed_components  (* Memory must work *)
  
  (* Degradation levels *)
  degradation_level = 0 ‚üπ failed_components = ‚àÖ
  degradation_level = 1 ‚üπ #failed_components ‚àà 1..2
  degradation_level = 2 ‚üπ #failed_components ‚àà 3..5
  degradation_level = 3 ‚üπ #failed_components > 5
end

(* ========================================================================
 * STATE TRANSITIONS
 * ======================================================================== *)

(*
 * State transitions capture system evolution over time
 *)

schema StateTransition
  before: AGIOSSystemState
  after: AGIOSSystemState
  elapsed_time: ‚Ñï‚ÇÅ
where
  (* Time moves forward *)
  after.current_time = before.current_time + elapsed_time
  after.uptime = before.uptime + elapsed_time
  
  (* Boot time never changes *)
  after.boot_time = before.boot_time
  
  (* Atom IDs only increase *)
  dom after.atomspace.atoms ‚äá dom before.atomspace.atoms
  
  (* Process IDs only increase (processes can terminate) *)
  ‚àÉ new_pids: ‚Ñô ProcessID ‚Ä¢
    dom after.cognumach.processes = 
      (dom before.cognumach.processes ‚à™ new_pids)
end

(* ========================================================================
 * SHUTDOWN STATE
 * ======================================================================== *)

schema ShutdownState
  extends AGIOSSystemState
  shutdown_reason: AtomName
  unsaved_atoms: ‚Ñô AtomID
where
  (* No active tasks *)
  #task_queue.tasks = 0
  
  (* CogServer stopped accepting connections *)
  ¬¨cogserver.is_listening
  
  (* Only essential processes remain *)
  #cognumach.processes ‚â§ 5
  
  (* Track unsaved data *)
  unsaved_atoms ‚äÜ dom atomspace.atoms
end

(* ========================================================================
 * END OF SYSTEM STATE SPECIFICATION
 * ======================================================================== *)

(*
 * This system state specification defines:
 * 
 * 1. Complete system state across all four layers
 * 2. Microkernel state (processes, memory, IPC)
 * 3. Operating system state (file systems, translators)
 * 4. Cognitive framework state (reasoning, learning, attention)
 * 5. Development tools state (CogBolt IDE)
 * 6. System-wide invariants and consistency conditions
 * 7. Initial, steady, degraded, and shutdown states
 * 
 * The next specification (operations.zpp) defines operations that
 * transform this state while maintaining invariants.
 *)
