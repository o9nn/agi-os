(*
 * AGI-OS Operations - Z++ Formal Specification
 * 
 * This specification formalizes the core operations that transform
 * the AGI-OS system state. Operations are organized by architectural
 * layer and functional subsystem.
 * 
 * Author: AGI-OS Development Team
 * Date: December 12, 2025
 * Version: 1.0
 *)

(* Import data model and system state *)
include "data_model.zpp"
include "system_state.zpp"

(* ========================================================================
 * ATOMSPACE OPERATIONS - CORE KNOWLEDGE MANAGEMENT
 * ======================================================================== *)

(*
 * AddNode: Add a new node to the AtomSpace
 * Nodes are identified by (type, name) pairs
 *)

schema AddNode
  Î”AtomSpaceState
  node_type: TypeID
  node_name: AtomName
  initial_tv?: TruthValueType
  initial_av?: AttentionValueSet
  result!: AtomID
where
  (* Pre-conditions *)
  node_type' âˆˆ dom type_index
  Â¬read_only
  
  (* Check if node already exists *)
  (node_type, node_name) âˆˆ dom name_index âŸ¹
    result! = name_index(node_type, node_name)
  
  (* Create new node if it doesn't exist *)
  (node_type, node_name) âˆ‰ dom name_index âŸ¹
    let new_id = atom_count + 1 in
    let new_node = Node {
      atom_id = new_id,
      atom_type = type_system(node_type),
      name = node_name,
      truth_value = initial_tv? âˆ¨ default_tv,
      attention_value = initial_av? âˆ¨ default_av,
      created_time = current_time,
      modified_time = current_time
    } in
      (* Update state *)
      atoms' = atoms âˆª {new_id â†¦ new_node} âˆ§
      name_index' = name_index âˆª {(node_type, node_name) â†¦ new_id} âˆ§
      type_index' = type_index âŠ• {node_type â†¦ (type_index(node_type) âˆª {new_id})} âˆ§
      atom_count' = atom_count + 1 âˆ§
      result! = new_id
  
  (* Unchanged *)
  incoming_index' = incoming_index
end

(*
 * AddLink: Add a new link to the AtomSpace
 * Links connect existing atoms
 *)

schema AddLink
  Î”AtomSpaceState
  link_type: TypeID
  outgoing_atoms: seq AtomID
  initial_tv?: TruthValueType
  initial_av?: AttentionValueSet
  result!: AtomID
where
  (* Pre-conditions *)
  link_type' âˆˆ dom type_index
  Â¬read_only
  #outgoing_atoms > 0
  
  (* All outgoing atoms must exist *)
  âˆ€ aid: outgoing_atoms â€¢ aid âˆˆ dom atoms
  
  (* Check if identical link already exists *)
  âˆƒ existing: dom atoms |
    atoms(existing) âˆˆ Link âˆ§
    atoms(existing).atom_type.type_id = link_type âˆ§
    atoms(existing).outgoing = outgoing_atoms âŸ¹
    result! = existing
  
  (* Create new link if it doesn't exist *)
  Â¬(âˆƒ existing: dom atoms |
    atoms(existing) âˆˆ Link âˆ§
    atoms(existing).atom_type.type_id = link_type âˆ§
    atoms(existing).outgoing = outgoing_atoms) âŸ¹
    let new_id = atom_count + 1 in
    let new_link = Link {
      atom_id = new_id,
      atom_type = type_system(link_type),
      outgoing = outgoing_atoms,
      arity = #outgoing_atoms,
      truth_value = initial_tv? âˆ¨ default_tv,
      attention_value = initial_av? âˆ¨ default_av,
      created_time = current_time,
      modified_time = current_time
    } in
      (* Update state *)
      atoms' = atoms âˆª {new_id â†¦ new_link} âˆ§
      type_index' = type_index âŠ• {link_type â†¦ (type_index(link_type) âˆª {new_id})} âˆ§
      atom_count' = atom_count + 1 âˆ§
      result! = new_id âˆ§
      
      (* Update incoming index for all outgoing atoms *)
      incoming_index' = incoming_index âŠ•
        {aid: outgoing_atoms â€¢ aid â†¦ (incoming_index(aid) âˆª {new_id})}
  
  (* Unchanged *)
  name_index' = name_index
end

(*
 * RemoveAtom: Remove an atom from the AtomSpace
 * Must handle incoming links (cascade delete or error)
 *)

schema RemoveAtom
  Î”AtomSpaceState
  atom_id: AtomID
  cascade: ğ”¹              (* If true, remove incoming links *)
  success!: ğ”¹
where
  (* Pre-conditions *)
  Â¬read_only
  atom_id âˆˆ dom atoms
  
  (* Check for incoming links *)
  let incoming_set = incoming_index(atom_id) in
  
  (* Cannot remove if has incoming links and not cascading *)
  Â¬cascade âˆ§ incoming_set â‰  âˆ… âŸ¹
    success! = false âˆ§
    atoms' = atoms âˆ§
    type_index' = type_index âˆ§
    name_index' = name_index âˆ§
    incoming_index' = incoming_index âˆ§
    atom_count' = atom_count
  
  (* Remove atom (and incoming links if cascading) *)
  (cascade âˆ¨ incoming_set = âˆ…) âŸ¹
    let removed_ids = {atom_id} âˆª (if cascade then incoming_set else âˆ…) in
    let removed_atom = atoms(atom_id) in
      (* Update atoms *)
      atoms' = removed_ids â©¤ atoms âˆ§
      
      (* Update type index *)
      type_index' = type_index âŠ•
        {removed_atom.atom_type.type_id â†¦ 
          (type_index(removed_atom.atom_type.type_id) \ removed_ids)} âˆ§
      
      (* Update name index if node *)
      (removed_atom âˆˆ Node âŸ¹
        name_index' = {(removed_atom.atom_type.type_id, removed_atom.name)} â©¤ name_index) âˆ§
      
      (* Update incoming index *)
      incoming_index' = incoming_index âŠ•
        (if removed_atom âˆˆ Link then
          {aid: removed_atom.outgoing â€¢ aid â†¦ 
            (incoming_index(aid) \ {atom_id})}
        else {}) âˆ§
      
      atom_count' = atom_count - #removed_ids âˆ§
      success! = true
end

(*
 * SetTruthValue: Update the truth value of an atom
 *)

schema SetTruthValue
  Î”AtomSpaceState
  atom_id: AtomID
  new_tv: TruthValueType
where
  (* Pre-conditions *)
  Â¬read_only
  atom_id âˆˆ dom atoms
  
  (* Update truth value *)
  let old_atom = atoms(atom_id) in
  let updated_atom = old_atom âŠ• {
    truth_value = new_tv,
    modified_time = current_time
  } in
    atoms' = atoms âŠ• {atom_id â†¦ updated_atom}
  
  (* Unchanged *)
  type_index' = type_index âˆ§
  name_index' = name_index âˆ§
  incoming_index' = incoming_index âˆ§
  atom_count' = atom_count
end

(*
 * SetAttentionValue: Update the attention value of an atom
 *)

schema SetAttentionValue
  Î”AtomSpaceState
  atom_id: AtomID
  new_av: AttentionValueSet
where
  (* Pre-conditions *)
  atom_id âˆˆ dom atoms
  
  (* Update attention value *)
  let old_atom = atoms(atom_id) in
  let updated_atom = old_atom âŠ• {
    attention_value = new_av,
    modified_time = current_time
  } in
    atoms' = atoms âŠ• {atom_id â†¦ updated_atom}
  
  (* Unchanged *)
  type_index' = type_index âˆ§
  name_index' = name_index âˆ§
  incoming_index' = incoming_index âˆ§
  atom_count' = atom_count
end

(* ========================================================================
 * PATTERN MATCHING OPERATIONS
 * ======================================================================== *)

(*
 * ExecuteQuery: Execute a pattern matching query
 *)

schema ExecuteQuery
  ÎAtomSpaceState           (* Read-only operation *)
  pattern: Pattern
  max_results?: â„•â‚
  solutions!: â„™ (VariableID â†¦ AtomID)
where
  (* Check cache first *)
  pattern âˆˆ dom query_cache âŸ¹
    solutions! = query_cache(pattern)
  
  (* Execute query if not cached *)
  pattern âˆ‰ dom query_cache âŸ¹
    (* All solutions satisfy the pattern *)
    âˆ€ solution: solutions! â€¢
      (* Variables bound to atoms *)
      dom solution = {v: pattern.variables â€¢ v.var_id} âˆ§
      (* Type constraints satisfied *)
      (âˆ€ vid: dom solution â€¢
        âˆƒ v: pattern.variables | v.var_id = vid â€¢
          atoms(solution(vid)).atom_type.type_id âˆˆ v.type_constraint) âˆ§
      (* Pattern clauses satisfied *)
      true  (* Simplified - full pattern matching logic *)
  
  (* Limit results if specified *)
  max_results? âŸ¹ #solutions! â‰¤ max_results?
end

(*
 * GetIncomingSet: Get all links pointing to an atom
 *)

schema GetIncomingSet
  ÎAtomSpaceState
  atom_id: AtomID
  incoming!: â„™ AtomID
where
  (* Pre-condition *)
  atom_id âˆˆ dom atoms
  
  (* Return incoming set *)
  atom_id âˆˆ dom incoming_index âŸ¹
    incoming! = incoming_index(atom_id)
  
  atom_id âˆ‰ dom incoming_index âŸ¹
    incoming! = âˆ…
end

(*
 * GetAtomsByType: Get all atoms of a given type
 *)

schema GetAtomsByType
  ÎAtomSpaceState
  type_id: TypeID
  include_subtypes: ğ”¹
  result!: â„™ AtomID
where
  (* Pre-condition *)
  type_id âˆˆ dom type_index
  
  (* Return atoms of exact type *)
  Â¬include_subtypes âŸ¹
    result! = type_index(type_id)
  
  (* Return atoms of type and subtypes *)
  include_subtypes âŸ¹
    result! = type_index(type_id) âˆª
      (â‹ƒ {subtype: dom type_index |
          type_id âˆˆ type_hierarchy(subtype).parent_type â€¢
          type_index(subtype)})
end

(* ========================================================================
 * ATTENTION ALLOCATION OPERATIONS (ECAN)
 * ======================================================================== *)

(*
 * SpreadAttention: Spread attention from atom to neighbors
 *)

schema SpreadAttention
  Î”AtomSpaceState
  Î”ECANState
  source_atom: AtomID
  spread_percentage: Probability
where
  (* Pre-conditions *)
  source_atom âˆˆ dom atoms
  0.0 < spread_percentage âˆ§ spread_percentage â‰¤ 1.0
  
  let source_sti = atoms(source_atom).attention_value.sti.sti in
  let spread_amount = âŒŠsource_sti * spread_percentageâŒ‹ in
  let incoming_set = incoming_index(source_atom) in
  let outgoing_set = (atoms(source_atom) âˆˆ Link âŸ¹ 
                      atoms(source_atom).outgoing) in
  let neighbors = incoming_set âˆª elems outgoing_set in
  
  (* Spread attention to neighbors *)
  spread_amount > 0 âˆ§ neighbors â‰  âˆ… âŸ¹
    let amount_per_neighbor = spread_amount div #neighbors in
    (* Update source STI *)
    atoms' = atoms âŠ• {source_atom â†¦ 
      atoms(source_atom) âŠ• {
        attention_value = atoms(source_atom).attention_value âŠ• {
          sti = {sti = source_sti - spread_amount}
        }
      }} âŠ•
    (* Update neighbor STIs *)
    {nid: neighbors â€¢ nid â†¦
      atoms(nid) âŠ• {
        attention_value = atoms(nid).attention_value âŠ• {
          sti = {sti = atoms(nid).attention_value.sti.sti + amount_per_neighbor}
        }
      }} âˆ§
    ecan.update_count' = ecan.update_count + 1
  
  (* Unchanged if no spread *)
  (spread_amount â‰¤ 0 âˆ¨ neighbors = âˆ…) âŸ¹
    atoms' = atoms âˆ§
    ecan' = ecan
end

(*
 * CollectRent: Decay STI values (attention rent)
 *)

schema CollectRent
  Î”AtomSpaceState
  Î”ECANState
where
  (* Apply rent collection to all atoms *)
  atoms' = {aid: dom atoms â€¢ aid â†¦
    atoms(aid) âŠ• {
      attention_value = atoms(aid).attention_value âŠ• {
        sti = {sti = âŒŠatoms(aid).attention_value.sti.sti * 
                      (1.0 - ecan.rent_collection_rate)âŒ‹}
      }
    }} âˆ§
  
  ecan.update_count' = ecan.update_count + 1 âˆ§
  
  (* Conservation: collect rent into funds *)
  let total_rent_collected = 
    (âˆ‘ aid: dom atoms â€¢ 
      âŒŠatoms(aid).attention_value.sti.sti * ecan.rent_collection_rateâŒ‹) in
    ecan.sti_funds_total' = ecan.sti_funds_total + total_rent_collected
end

(*
 * UpdateAttentionalFocus: Update the attentional focus
 *)

schema UpdateAttentionalFocus
  Î”AtomSpaceState
where
  (* Rebuild attentional focus based on STI *)
  let high_sti_atoms = {aid: dom atoms |
    atoms(aid).attention_value.sti.sti â‰¥ attention_focus.sti_threshold} in
  
  (* Take top N atoms by STI *)
  attention_focus.focus_atoms' = 
    take attention_focus.max_size
         (sort_by_sti_desc high_sti_atoms)
  
  (* Unchanged *)
  atoms' = atoms
end

(* ========================================================================
 * INFERENCE OPERATIONS (PLN)
 * ======================================================================== *)

(*
 * ApplyInferenceRule: Apply a PLN inference rule
 *)

schema ApplyInferenceRule
  Î”AtomSpaceState
  Î”PLNState
  rule_id: AtomID
  premises: â„™ AtomID
  conclusion!: AtomID
where
  (* Pre-conditions *)
  rule_id âˆˆ pln.rule_base
  premises âŠ† dom atoms
  premises â‰  âˆ…
  
  (* All premises have sufficient confidence *)
  âˆ€ p: premises â€¢
    atoms(p).truth_value.confidence â‰¥ pln.confidence_threshold
  
  (* Apply rule to generate conclusion *)
  let conclusion_tv = infer_truth_value(rule_id, premises) in
  conclusion_tv.confidence â‰¥ pln.confidence_threshold âŸ¹
    (* Create conclusion atom *)
    let new_conclusion = construct_conclusion(rule_id, premises, conclusion_tv) in
    (* Add to atomspace *)
    conclusion! = add_atom(new_conclusion) âˆ§
    pln.inference_count' = pln.inference_count + 1 âˆ§
    pln.active_inferences' = pln.active_inferences âˆª {conclusion!}
  
  conclusion_tv.confidence < pln.confidence_threshold âŸ¹
    (* Insufficient confidence, no conclusion *)
    conclusion! = 0 âˆ§
    pln' = pln
end

(*
 * ForwardChain: Execute forward chaining inference
 *)

schema ForwardChain
  Î”AtomSpaceState
  Î”UREState
  starting_atoms: â„™ AtomID
  max_steps: â„•â‚
  derived_atoms!: â„™ AtomID
where
  (* Pre-conditions *)
  starting_atoms âŠ† dom atoms
  starting_atoms â‰  âˆ…
  
  (* Execute forward chaining *)
  let current_iteration = 0 in
  let derived = starting_atoms in
  while current_iteration < max_steps âˆ§ 
        current_iteration < ure.max_iterations do
    (* Apply forward rules to current derived set *)
    let new_derived = apply_forward_rules(derived, ure.forward_rules) in
    derived = derived âˆª new_derived
    current_iteration = current_iteration + 1
  
  derived_atoms! = derived \ starting_atoms âˆ§
  ure.current_iteration' = ure.current_iteration + current_iteration
end

(*
 * BackwardChain: Execute backward chaining to prove goal
 *)

schema BackwardChain
  Î”AtomSpaceState
  Î”UREState
  goal_atom: AtomID
  max_depth: â„•â‚
  proof_found!: ğ”¹
  proof_trace!: seq AtomID
where
  (* Pre-conditions *)
  goal_atom âˆˆ dom atoms
  
  (* Execute backward chaining *)
  let success = backward_chain_recursive(
    goal_atom, 
    ure.backward_rules, 
    max_depth,
    proof_trace!
  ) in
  
  proof_found! = success âˆ§
  ure.current_iteration' = ure.current_iteration + #proof_trace!
end

(* ========================================================================
 * LEARNING OPERATIONS (MOSES)
 * ======================================================================== *)

(*
 * EvolvePrograms: Evolve program population
 *)

schema EvolvePrograms
  Î”MOSESState
  fitness_function: AtomID â†’ â„
where
  (* Pre-conditions *)
  moses.current_generation < moses.max_generations
  
  (* Select parents *)
  let parents = tournament_selection(
    moses.population, 
    moses.fitness_cache,
    moses.population_size div 2
  ) in
  
  (* Generate offspring *)
  let offspring = crossover_and_mutate(parents) in
  
  (* Evaluate offspring fitness *)
  let new_fitness = {p: offspring â€¢ p â†¦ fitness_function(p)} in
  
  (* Update population (elitism: keep best individuals) *)
  let combined = moses.population ++ offspring in
  let sorted = sort_by_fitness_desc(combined, 
                                     moses.fitness_cache âˆª new_fitness) in
  
  moses.population' = take moses.population_size sorted âˆ§
  moses.fitness_cache' = moses.fitness_cache âˆª new_fitness âˆ§
  moses.current_generation' = moses.current_generation + 1 âˆ§
  moses.best_fitness' = max(ran(moses.fitness_cache'))
end

(*
 * MinePatterns: Discover frequent patterns
 *)

schema MinePatterns
  ÎAtomSpaceState
  Î”PatternMinerState
  target_atoms: â„™ AtomID
  new_patterns!: â„™ AtomID
where
  (* Pre-conditions *)
  target_atoms âŠ† dom atoms
  
  (* Mine patterns from target atoms *)
  let candidates = generate_candidate_patterns(
    target_atoms,
    pattern_miner.max_conjuncts
  ) in
  
  (* Count pattern frequency *)
  let freq_map = {p: candidates â€¢ 
    p â†¦ count_pattern_instances(p, atoms)} in
  
  (* Filter by minimum support *)
  let frequent_patterns = {p: candidates |
    freq_map(p) â‰¥ pattern_miner.min_support} in
  
  (* Add new patterns *)
  new_patterns! = frequent_patterns \ pattern_miner.discovered_patterns âˆ§
  pattern_miner.discovered_patterns' = 
    pattern_miner.discovered_patterns âˆª new_patterns! âˆ§
  pattern_miner.pattern_frequency' = 
    pattern_miner.pattern_frequency âˆª 
    {p: new_patterns! â€¢ p â†¦ freq_map(p)}
end

(* ========================================================================
 * PERSISTENCE OPERATIONS
 * ======================================================================== *)

(*
 * StoreAtoms: Persist atoms to storage backend
 *)

schema StoreAtoms
  ÎAtomSpaceState
  backend: StorageBackend
  atom_ids: â„™ AtomID
  success!: ğ”¹
where
  (* Pre-conditions *)
  backend.is_connected
  Â¬backend.read_only
  atom_ids âŠ† dom atoms
  
  (* Store each atom *)
  let store_results = {aid: atom_ids â€¢ 
    aid â†¦ backend.store_atom(atoms(aid))} in
  
  (* Success if all atoms stored *)
  success! = (âˆ€ r: ran store_results â€¢ r = true)
end

(*
 * LoadAtoms: Load atoms from storage backend
 *)

schema LoadAtoms
  Î”AtomSpaceState
  backend: StorageBackend
  query_pattern: Pattern
  loaded_ids!: â„™ AtomID
where
  (* Pre-conditions *)
  backend.is_connected
  Â¬read_only
  
  (* Load atoms matching pattern *)
  let loaded_atoms = backend.fetch_atoms(query_pattern) in
  
  (* Add loaded atoms to atomspace *)
  loaded_ids! = {a: loaded_atoms â€¢ add_atom(a)} âˆ§
  
  (* Update atom count *)
  atom_count' = atom_count + #loaded_ids!
end

(* ========================================================================
 * COGSERVER OPERATIONS
 * ======================================================================== *)

(*
 * HandleClientRequest: Process a client request
 *)

schema HandleClientRequest
  ÎAtomSpaceState
  Î”CogServerState
  client_id: â„•
  request_type: AtomName
  request_data: â„™ KeyValuePair
  response!: â„™ KeyValuePair
  success!: ğ”¹
where
  (* Pre-conditions *)
  cogserver.is_listening
  âˆƒ addr: â„™ (AtomName Ã— â„•) â€¢ (addr, client_id) âˆˆ cogserver.connected_clients
  
  (* Route request to handler *)
  request_type = "get_atom" âŸ¹
    response! = handle_get_atom(request_data) âˆ§ success! = true
  
  request_type = "add_atom" âŸ¹
    response! = handle_add_atom(request_data) âˆ§ success! = true
  
  request_type = "execute_query" âŸ¹
    response! = handle_execute_query(request_data) âˆ§ success! = true
  
  request_type âˆ‰ {"get_atom", "add_atom", "execute_query"} âŸ¹
    response! = {("error", "unknown_request_type")} âˆ§ success! = false
  
  (* Update request count *)
  cogserver.request_count' = cogserver.request_count + 1 âˆ§
  cogserver.last_request_time' = current_time
end

(*
 * AcceptConnection: Accept a new client connection
 *)

schema AcceptConnection
  Î”CogServerState
  client_address: AtomName
  client_id!: â„•
where
  (* Pre-condition *)
  cogserver.is_listening
  
  (* Generate new client ID *)
  client_id! = (#cogserver.connected_clients) + 1
  
  (* Add client *)
  cogserver.connected_clients' = 
    cogserver.connected_clients âˆª {(client_address, client_id!)}
end

(*
 * CloseConnection: Close a client connection
 *)

schema CloseConnection
  Î”CogServerState
  client_id: â„•
where
  (* Remove client *)
  cogserver.connected_clients' = 
    {(addr, cid): cogserver.connected_clients | cid â‰  client_id}
end

(* ========================================================================
 * TASK SCHEDULING OPERATIONS
 * ======================================================================== *)

(*
 * EnqueueTask: Add a task to the task queue
 *)

schema EnqueueTask
  Î”TaskQueue
  task: CognitiveTask
  success!: ğ”¹
where
  (* Pre-conditions *)
  #tasks < max_size
  task.task_id âˆ‰ {t: tasks â€¢ t.task_id}
  
  (* Add task and maintain priority order *)
  #tasks < max_size âŸ¹
    tasks' = insert_sorted_by_priority(tasks, task) âˆ§
    success! = true
  
  #tasks â‰¥ max_size âŸ¹
    tasks' = tasks âˆ§
    success! = false
end

(*
 * DequeueTask: Remove and return highest priority task
 *)

schema DequeueTask
  Î”TaskQueue
  task!: CognitiveTask
  success!: ğ”¹
where
  (* Pre-conditions *)
  #tasks > 0 âŸ¹
    task! = head tasks âˆ§
    tasks' = tail tasks âˆ§
    success! = true
  
  #tasks = 0 âŸ¹
    success! = false âˆ§
    tasks' = tasks
end

(* ========================================================================
 * EVENT BUS OPERATIONS
 * ======================================================================== *)

(*
 * PublishEvent: Publish an event to the event bus
 *)

schema PublishEvent
  Î”EventQueue
  event: CognitiveEvent
where
  (* Add event and maintain order *)
  events' = insert_sorted_by_priority_timestamp(events, event)
end

(*
 * ConsumeEvent: Consume next event from queue
 *)

schema ConsumeEvent
  Î”EventQueue
  event!: CognitiveEvent
  success!: ğ”¹
where
  #events > 0 âŸ¹
    event! = head events âˆ§
    events' = tail events âˆ§
    success! = true
  
  #events = 0 âŸ¹
    success! = false âˆ§
    events' = events
end

(* ========================================================================
 * SYSTEM-LEVEL OPERATIONS
 * ======================================================================== *)

(*
 * BootSystem: Initialize AGI-OS from power-on
 *)

schema BootSystem
  AGIOSSystemState'
where
  (* Initialize microkernel *)
  cognumach'.processes = {1 â†¦ init_process} âˆ§
  cognumach'.memory_regions = initialize_memory() âˆ§
  cognumach'.ports = initialize_ports() âˆ§
  
  (* Initialize OS *)
  hurdcog'.translators = initialize_translators() âˆ§
  hurdcog'.file_system = initialize_root_fs() âˆ§
  
  (* Initialize cognitive framework *)
  atomspace'.atoms = âˆ… âˆ§
  atomspace'.atom_count = 0 âˆ§
  cogserver'.is_listening = true âˆ§
  
  (* Initialize learning *)
  ecan'.sti_funds_total = 100000 âˆ§
  ecan'.lti_funds_total = 100000 âˆ§
  
  (* Set boot time *)
  boot_time' = current_time âˆ§
  uptime' = 0
end

(*
 * ShutdownSystem: Gracefully shut down AGI-OS
 *)

schema ShutdownSystem
  Î”AGIOSSystemState
  reason: AtomName
where
  (* Stop accepting new requests *)
  cogserver'.is_listening = false âˆ§
  
  (* Persist unsaved atoms *)
  let unsaved = {aid: dom atomspace.atoms | 
    needs_persistence(aid)} in
  store_atoms(unsaved) âˆ§
  
  (* Terminate non-essential processes *)
  cognumach'.processes = 
    {pid: dom cognumach.processes | is_essential(pid)} âˆ§
  
  (* Clear task queues *)
  task_queue'.tasks = âŸ¨âŸ© âˆ§
  event_queue'.events = âŸ¨âŸ©
end

(* ========================================================================
 * COMPOSITE OPERATIONS
 * ======================================================================== *)

(*
 * PerformInferenceStep: Complete inference cycle
 *)

schema PerformInferenceStep
  Î”AtomSpaceState
  Î”PLNState
  Î”ECANState
where
  (* Select high-STI atoms for inference *)
  let focus_atoms = atomspace.attention_focus.focus_atoms in
  
  (* Apply inference rules *)
  âˆ€ rule: pln.rule_base â€¢
    let applicable_premises = 
      find_applicable_premises(rule, focus_atoms) in
    applicable_premises â‰  âˆ… âŸ¹
      ApplyInferenceRule(rule, applicable_premises)
  
  (* Update attention based on inference results *)
  UpdateAttentionalFocus
end

(*
 * CognitiveLoop: Main cognitive processing loop
 *)

schema CognitiveLoop
  Î”AGIOSSystemState
where
  (* Process events *)
  #event_queue.events > 0 âŸ¹ ConsumeEvent
  
  (* Execute tasks *)
  #task_queue.tasks > 0 âŸ¹ DequeueTask
  
  (* Attention dynamics *)
  CollectRent âˆ§ UpdateAttentionalFocus
  
  (* Inference *)
  PerformInferenceStep
  
  (* Learning *)
  moses.current_generation < moses.max_generations âŸ¹
    EvolvePrograms
  
  (* Pattern mining *)
  let high_frequency_atoms = select_high_access_atoms(100) in
  MinePatterns(high_frequency_atoms)
  
  (* Advance time *)
  current_time' = current_time + 1 âˆ§
  uptime' = uptime + 1
end

(* ========================================================================
 * END OF OPERATIONS SPECIFICATION
 * ======================================================================== *)

(*
 * This operations specification defines:
 * 
 * 1. AtomSpace operations (add, remove, query atoms)
 * 2. Pattern matching and query execution
 * 3. Attention allocation (ECAN) operations
 * 4. Inference operations (PLN, URE)
 * 5. Learning operations (MOSES, pattern mining)
 * 6. Persistence operations (storage backends)
 * 7. CogServer network operations
 * 8. Task scheduling and event handling
 * 9. System-level operations (boot, shutdown)
 * 10. Composite cognitive processing loops
 * 
 * All operations maintain system invariants and specify precise
 * pre-conditions and post-conditions.
 *)
